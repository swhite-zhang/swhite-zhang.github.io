<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++程序设计语言（四）——基本类型及类型转换</title>
      <link href="/2020/02/24/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2020/02/24/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="C-程序设计语言（四）——基本类型及类型转换"><a href="#C-程序设计语言（四）——基本类型及类型转换" class="headerlink" title="C++程序设计语言（四）——基本类型及类型转换"></a>C++程序设计语言（四）——基本类型及类型转换</h1><p>C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。</p><a id="more"></a><h2 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h2><p>算术类型分为整型和浮点型。</p><table><thead><tr><th>类型</th><th>名称</th><th>最小大小</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16位</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16位</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32位</td></tr><tr><td>short</td><td>短整型</td><td>16位</td></tr><tr><td>int</td><td>整型</td><td>16位</td></tr><tr><td>long</td><td>长整型</td><td>32位</td></tr><tr><td>long long</td><td>长整型（在C++11中定义）</td><td>64位</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展精度浮点数</td><td>10位有效数字</td></tr></tbody></table><p><strong>注意</strong>：不同的类型的大小在不同的机器上会有差别。一个char的大小通常和一个机器字节一样大。</p><p><strong>字节（byte）</strong></p><p>可寻址的最小内存块。</p><p><strong>字（word）</strong></p><p>存储的基本单元，通常是四字节或八字节（<strong>根据计算机的不同而改变</strong>）。</p><h3 id="带符号类型（signed）和无符号类型（unsigned）"><a href="#带符号类型（signed）和无符号类型（unsigned）" class="headerlink" title="带符号类型（signed）和无符号类型（unsigned）"></a>带符号类型（signed）和无符号类型（unsigned）</h3><p>它们的差别是：无符号类型的所有比特都用来存储值，而带符号的最高位用来表示符号。</p><p>类型int、short、long和long long都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型。</p><p>而字符型有三种：char、signed char 和 unsigned char。需要注意char和signed char并不一样。字符型具体表现为带符号的还是无符号的由编译器决定。</p><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>当我们在编程的时候，应该尽量遵循以下原则：</p><ul><li>当明确知道数值不可能位负时，选用无符号类型。</li><li>在算数表达式中不使用char或bool类型。</li><li>执行浮点数运算选用精度更高的double。</li></ul><h2 id="空类型"><a href="#空类型" class="headerlink" title="空类型"></a>空类型</h2><p>即void类型。常用于定义函数的参数类型、返回值和指针类型。用于函数的参数类型表示无参数列表；用于函数返回值表示无返回值；用于指针类型表示未知类型的指针，可以将任意类型的指针直接赋值给void指针。<strong>不能用于声明一个变量</strong>。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换通常满足一下规律：</p><ul><li>非布尔类型转换为布尔类型时，0会转换为false，否则转换为true。</li><li>当布尔类型赋给非布尔类型时，false会转换为0，true会转换为1。</li><li>浮点数转换为整型时，仅保留整数部分。</li><li>将整数转换为浮点类型时，小数部分为零。如果整数的空间超过了浮点类型的大小，精度将会损失。</li><li>当我们赋给一个无符号类型一个超出它表示范围的值时，结果会变为对这个值取无符号类型表示数值最大值的模。</li><li>当我们赋给一个有符号类型一个超出它表示范围的值时，结果是未定义的。</li></ul><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>当程序执行过程中，我们使用的类型和要求不同时，程序会自动进行类型转换。</p><ul><li>在表达式中，比int类型小的整型值提升为较大的整型类型。</li><li>在条件中，非布尔值转成布尔类型</li><li>初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象装换成左侧运算对象的类型。</li><li>如果算术运算或关系运算的运算对象有多种类型，会转换成同一种类型。</li></ul><h4 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h4><p>把一种算术类型转换成另一种算术类型。</p><p><strong>整型提升</strong></p><p>把小整数类型转换成较大的整数类型。对于bool、char、signed char、unsigned char、short和unsigned short，它们如果能够存入int，就会转化为int类型，否则转换为unsigned int类型。</p><p>而对于wchar_t、char16_t、char32_t则转换成int、unsigned int、long、unsigned long、long long或unsigned long long中可以存入的最小的类型。</p><p><strong>无符号类型的运算对象</strong></p><p>当运算中有不同类型的运算对象时，先会执行整型提升。如果类型相同则结束，否则较小类型的会转换为较大的类型。</p><h4 id="其他隐式转换"><a href="#其他隐式转换" class="headerlink" title="其他隐式转换"></a>其他隐式转换</h4><p><strong>数组转换成指针</strong></p><p>通常，数组自动转换成指向数组首元素的指针。当数组被用作decltype关键字的参数、作为取地址符、sizeof及typeid等运算符的运算对象或者用一个引用来初始化数组时不会发生此转换。</p><p><strong>转换成常量</strong></p><p>指向非常量类型的指针或引用可以转换成指向相应的常量类型的指针或引用。</p><h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p><strong>强制类型转换（cast）</strong>使用某种方法将一种类型的变量显示的转换为另一种变量。不推荐这种做法，因为它本是上是十分危险的。</p><h4 id="命名的强制类型转换"><a href="#命名的强制类型转换" class="headerlink" title="命名的强制类型转换"></a>命名的强制类型转换</h4><p>形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-name&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure><ul><li>type是转换的目标类型</li><li>expression是要转换的值</li><li>cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。</li></ul><p><strong>static_cast</strong></p><p><strong>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</strong>。通常我们将较大类型转换成较小类型时使用static_cast。</p><p><strong>dynamic_cast</strong><br>用于将子类转换为基类。当<strong>错误的将基类转换为子类时不会报错</strong>，但是无法达到预期效果。</p><p><strong>const_cast</strong></p><p>它只能改变运算对象的底层const。只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换都会引发编译器错误。用来将常量指针或引用转换成非常量的指针或引用，并且仍然指向原来的对象。</p><p><strong>reinterpert_cast</strong></p><p>通常为运算对象的位模式提供叫低层次上的重新解释。用于任意指针之间的转换，引用之间的转换，指针和足够大的整型之间的转换以及整数到指针的转换。</p><h4 id="旧式的强制类型转换"><a href="#旧式的强制类型转换" class="headerlink" title="旧式的强制类型转换"></a>旧式的强制类型转换</h4><p>C语言风格的强制类型转换。</p><p>形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type (expr);</span><br><span class="line">(type) expr;</span><br></pre></td></tr></table></figure><p>这种转换方法和上面的效果相同。不过如果出错追踪起来更加困难。</p><p><strong>注意：</strong>强制类型转换干扰了正常的类型检查，因此应当避免使用强制类型转换。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序设计语言（三）——循环分支语句</title>
      <link href="/2020/02/23/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5/"/>
      <url>/2020/02/23/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="C-程序设计语言（三）——循环分支语句"><a href="#C-程序设计语言（三）——循环分支语句" class="headerlink" title="C++程序设计语言（三）——循环分支语句"></a>C++程序设计语言（三）——循环分支语句</h1><p>C++中提供了while语句、do while语句、for语句、if语句和switch语句。</p><a id="more"></a><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( condition )</span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while语句的执行过程是交替地检测condition条件和语句块中的statement，直到<br>condition。<strong>当statement只有一条语句时，可以不用加大括号（下同）；这里的condition是一段布尔表达式</strong>。</p><h2 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h2><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>( condition );</span><br></pre></td></tr></table></figure><p>和while语句不同的是，do while语句会先执行以便statement然后才判断condition，所以无论如何do while语句都至少会执行一次，而while语句可能一次都不会执行。</p><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( init-statement ; condition ; expression )</span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for语句在进入的时候会先执行init-statement语句。然判断condition，如果为真<br>进入statement，然后执行expression，由此重复直到condition</p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( condition )</span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( condition )</span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在if语句中，程序会执行condition为真中的statement。当所有的condition都假时，程序执行else中的statement。要注意else if必须在if之后、else之前。</p><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( expression )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression :statement;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant-expression :statement;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant-expression :statement;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在switch语句中，expression必须是某种数据类型；constant-expression必须和expression又相同的数据类型且必须是一个常量或字面量，当其值和expression相同时程序就会执行后面的statement。注意，如果后面没有break，程序会继续执行后面的代码。default是可选项，当上面所有的constant-expression都与expression不匹配时，默认执行。</p><h2 id="continue和break"><a href="#continue和break" class="headerlink" title="continue和break"></a>continue和break</h2><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue语句通常用于循环语句中，它会<strong>跳过当前循环</strong>中的代码，开始下一次循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span> ( n &lt; <span class="number">20</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( n == <span class="number">6</span>  )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"666"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 跳过后面的代码到下次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break语句用于循环语句中会<strong>跳出当前循环</strong>。用于switch语句中会直接跳出switch语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( i &lt; <span class="number">100</span> )</span><br><span class="line">&#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">66</span> )</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//当i等于66时跳出当前循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（十三）——Scrapy爬取豆瓣图书</title>
      <link href="/2020/02/09/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Scrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%9B%BE%E4%B9%A6/"/>
      <url>/2020/02/09/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Scrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%9B%BE%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫（十三）——Scrapy爬取豆瓣图书"><a href="#Python爬虫（十三）——Scrapy爬取豆瓣图书" class="headerlink" title="Python爬虫（十三）——Scrapy爬取豆瓣图书"></a>Python爬虫（十三）——Scrapy爬取豆瓣图书</h1><p>这次我们爬取豆瓣图书的top250的目录后进入书籍界面爬取界面中的书籍标签。</p><p><img src="/2020/02/09/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Scrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%9B%BE%E4%B9%A6/top250.png" alt="top250" title="top250"></p><p><img src="/2020/02/09/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Scrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%9B%BE%E4%B9%A6/top250tag.png" alt="top250tag" title="top250tag"></p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="建立项目和Spider模板"><a href="#建立项目和Spider模板" class="headerlink" title="建立项目和Spider模板"></a>建立项目和Spider模板</h3><p>使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject demo</span><br><span class="line">cd demo</span><br><span class="line">scrapy genspider book</span><br></pre></td></tr></table></figure><h3 id="编写Spider"><a href="#编写Spider" class="headerlink" title="编写Spider"></a>编写Spider</h3><p>我们首先在top250的界面中爬取到每本书籍的url。打开网页观察代码：</p><p><img src="/2020/02/09/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Scrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%9B%BE%E4%B9%A6/bookurl.png" alt="bookurl" title="bookurl"></p><p>经过观察，我们发现书籍的信息在标签tr属性为item的代码块中，而书籍的url则是在标签a中。利用yield将这个请求的结果返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        soup = BeautifulSoup(response.text, <span class="string">'html.parser'</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> soup.find_all(<span class="string">'tr'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'item'</span>&#125;):</span><br><span class="line">            <span class="keyword">for</span> href <span class="keyword">in</span> item.find_all(<span class="string">'a'</span>):</span><br><span class="line">                <span class="keyword">if</span> href.string != <span class="literal">None</span>:</span><br><span class="line">                    url = href.attrs[<span class="string">'href'</span>]</span><br><span class="line">                    <span class="keyword">yield</span> scrapy.Request(url, callback=self.parse_book)</span><br></pre></td></tr></table></figure><p>然后打开书籍信息界面的源代码搜索tag找到了书籍标签的所在位置</p><p><img src="/2020/02/09/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Scrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%9B%BE%E4%B9%A6/booktag.png" alt="booktag" title="booktag"></p><p>发现我们可以用正则表达式’tag/.*?”‘来得到书籍的标签,然后用yield来返回得到的书籍信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_book</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        infoDict = &#123;&#125;</span><br><span class="line">        booksoup = BeautifulSoup(</span><br><span class="line">                response.text, <span class="string">'html.parser'</span>)</span><br><span class="line">        infoDict.update(</span><br><span class="line">                &#123;<span class="string">'bookname'</span>: booksoup.title.string[:<span class="number">-4</span>]&#125;)</span><br><span class="line">        tagInfo = re.findall(<span class="string">'tag/.*?"'</span>, response.text)</span><br><span class="line">        tag = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tagInfo:</span><br><span class="line">            tag.append(i[<span class="number">4</span>:])</span><br><span class="line">        infoDict[<span class="string">'tag'</span>] = tag</span><br><span class="line">        <span class="keyword">yield</span> infoDict</span><br></pre></td></tr></table></figure><h3 id="编写Pipelines"><a href="#编写Pipelines" class="headerlink" title="编写Pipelines"></a>编写Pipelines</h3><p>在pipelines.py文件中我们设定一个filename来存放文件名，然后打开这个文件将得到的内容写进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'book.txt'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.f = open(self.filename, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.f.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            line = str(dict(item)) + <span class="string">'\n'</span></span><br><span class="line">            self.f.write(line)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h3 id="配置settings"><a href="#配置settings" class="headerlink" title="配置settings"></a>配置settings</h3><p>打开settings.py文件，将pipelines设定为我们所编写的类：</p><p><img src="/2020/02/09/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Scrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%9B%BE%E4%B9%A6/pipeline.png" alt="pipeline" title="pipeline"></p><h3 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h3><p>最后打开命令行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl book</span><br></pre></td></tr></table></figure><p>运行结束后文件夹中就会得到一个book.txt文件：</p><p><img src="/2020/02/09/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Scrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%9B%BE%E4%B9%A6/got.png" alt="got" title="got"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>book.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'book'</span></span><br><span class="line">    start_urls = [<span class="string">'https://book.douban.com/top250?icn=index-book250-all'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        soup = BeautifulSoup(response.text, <span class="string">'html.parser'</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> soup.find_all(<span class="string">'tr'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'item'</span>&#125;):</span><br><span class="line">            <span class="keyword">for</span> href <span class="keyword">in</span> item.find_all(<span class="string">'a'</span>):</span><br><span class="line">                <span class="keyword">if</span> href.string != <span class="literal">None</span>:</span><br><span class="line">                    url = href.attrs[<span class="string">'href'</span>]</span><br><span class="line">                    <span class="keyword">yield</span> scrapy.Request(url, callback=self.parse_book)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_book</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        infoDict = &#123;&#125;</span><br><span class="line">        booksoup = BeautifulSoup(</span><br><span class="line">            response.text, <span class="string">'html.parser'</span>)</span><br><span class="line">        infoDict.update(</span><br><span class="line">            &#123;<span class="string">'bookname'</span>: booksoup.title.string[:<span class="number">-4</span>]&#125;)</span><br><span class="line">        tagInfo = re.findall(<span class="string">'tag/.*?"'</span>, response.text)</span><br><span class="line">        tag = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tagInfo:</span><br><span class="line">            tag.append(i[<span class="number">4</span>:])</span><br><span class="line">        infoDict[<span class="string">'tag'</span>] = tag</span><br><span class="line">        <span class="keyword">yield</span> infoDict</span><br></pre></td></tr></table></figure><p>pipelines.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don't forget to add your pipeline to the ITEM_PIPELINES setting</span></span><br><span class="line"><span class="comment"># See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    filename = <span class="string">'book.txt'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.f = open(self.filename, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.f.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            line = str(dict(item)) + <span class="string">'\n'</span></span><br><span class="line">            self.f.write(line)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p><strong>最后我要感谢慕课网北京理工大学嵩天老师开设的Python网络爬虫与信息提取这门课程，我的学习笔记都是对其课程的记录和自己的实践。没有嵩老师的课程我将无法学习到Python爬虫的那么多知识。感谢嵩老师和他的团队！<a href="https://www.icourse163.org/course/BIT-1001870001" target="_blank" rel="noopener">传送门</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（十二）——scrapy使用</title>
      <link href="/2020/02/08/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94scrapy%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/08/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94scrapy%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫（十二）——scrapy使用"><a href="#Python爬虫（十二）——scrapy使用" class="headerlink" title="Python爬虫（十二）——scrapy使用"></a>Python爬虫（十二）——scrapy使用</h1><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="创建一个scrapy工程"><a href="#创建一个scrapy工程" class="headerlink" title="创建一个scrapy工程"></a>创建一个scrapy工程</h3><p>到你要建立的目录下面，打开命令行，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject demo</span><br></pre></td></tr></table></figure><p>将会产生如图的文件：</p><p><img src="/2020/02/08/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94scrapy%E4%BD%BF%E7%94%A8/demo.png" alt="demo" title="demo"></p><p>其中包含一下文件</p><ul><li>scrapy.cfg 部署Scrapy爬虫的配置文件</li><li>demo 用户自定义Python代码<ul><li>_init_.py 初始化脚本</li><li>items.py Items代码模板</li><li>middlewares.py Middlewares代码模板</li><li>pipeline.py Pipeline代码模板</li><li>settings.py Scrapy爬虫的配置文件</li><li>spiders/ Spiders代码模板目录，存放这个工程中所建立的爬虫<ul><li>_init_.py 初始文件</li><li>_pycache_/ 缓存目录</li></ul></li></ul></li></ul><h3 id="在一个工程中创建一个Spider模板"><a href="#在一个工程中创建一个Spider模板" class="headerlink" title="在一个工程中创建一个Spider模板"></a>在一个工程中创建一个Spider模板</h3><p>在demo文件中输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider demo123 python123.io</span><br></pre></td></tr></table></figure><p>可以看到在demo/spiders中增加了一个demo123.py文件。</p><p><img src="/2020/02/08/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94scrapy%E4%BD%BF%E7%94%A8/demo123.png" alt="demo123" title="demo123"></p><h4 id="demo123-py"><a href="#demo123-py" class="headerlink" title="demo123.py"></a>demo123.py</h4><p>初始代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo123Spider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'demo123'</span> <span class="comment"># 当前爬虫名字</span></span><br><span class="line">    allowed_domains = [<span class="string">'python123.io'</span>] <span class="comment"># 提交给命令行的域名</span></span><br><span class="line">    start_urls = [<span class="string">'http://python123.io/'</span>] <span class="comment"># scrapy框架索要爬取的页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def start_request(self):</span></span><br><span class="line">    <span class="comment">#     urls = [</span></span><br><span class="line">    <span class="comment">#         'http://python123.io/ws/demo.html'</span></span><br><span class="line">    <span class="comment">#     ]</span></span><br><span class="line">    <span class="comment">#     for url in urls:</span></span><br><span class="line">    <span class="comment">#         yield scrapy.Request(url=url, callback=self.parse) # 节省空间，提高效率</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span> <span class="comment"># 处理响应</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h5 id="yield关键字的使用"><a href="#yield关键字的使用" class="headerlink" title="yield关键字的使用"></a>yield关键字的使用</h5><p>如果一个函数包含yield语句，那它就是一个生成器。生成器是一个不断产生值的函数。生成器中的yield产生一个值后函数被冻结，而这个值将返回。被再次唤醒后生成器将继续从这个位置执行。在这个过程中函数的局部变量是不变的。</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">yield</span> i**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squ</span><span class="params">(n)</span>:</span></span><br><span class="line">    ls = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">return</span> ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> gen(<span class="number">5</span>):</span><br><span class="line">    print(i, <span class="string">''</span>, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> squ(<span class="number">5</span>):</span><br><span class="line">    print(i, <span class="string">''</span>, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p><img src="/2020/02/08/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94scrapy%E4%BD%BF%E7%94%A8/yield.png" alt="yieldDemo" title="yieldDemo"></p><p>生成器的优势是节省存储空间、提高运行速度、使用更加灵活。在spider中使用yield可以在爬取大量网页的过程中节省空间，提高效率。</p><h4 id="配置产生的spider爬虫"><a href="#配置产生的spider爬虫" class="headerlink" title="配置产生的spider爬虫"></a>配置产生的spider爬虫</h4><p>修改demo123.py文件，使它能够按照我们的要求去访问链接并提取数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo123Spider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'demo123'</span></span><br><span class="line">    <span class="comment">#allowed_domains = ['python123.io']</span></span><br><span class="line">    start_urls = [<span class="string">'http://python123.io/ws/demo.html'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span>  <span class="comment"># response 是从Internet中返回的数据包</span></span><br><span class="line">        fname = response.url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]  <span class="comment"># 从response中提取名字作为文件名</span></span><br><span class="line">        <span class="keyword">with</span> open(fname, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.body)  <span class="comment"># 将response中的内容保存到文件中</span></span><br><span class="line">        self.log(<span class="string">'Saved file &amp;s.'</span> &amp; name)</span><br></pre></td></tr></table></figure><h4 id="运行爬虫，获取网页"><a href="#运行爬虫，获取网页" class="headerlink" title="运行爬虫，获取网页"></a>运行爬虫，获取网页</h4><p>在命令行中输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl demo123</span><br></pre></td></tr></table></figure><p>在demo目录下将会生成demo123.html文件。</p><p><img src="/2020/02/08/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94scrapy%E4%BD%BF%E7%94%A8/gothtml.png" alt="gotHTML" title="gotHTML"></p><h3 id="编写Item-Pipeline"><a href="#编写Item-Pipeline" class="headerlink" title="编写Item Pipeline"></a>编写Item Pipeline</h3><p>编辑在创建工程的时候得到的pipeline.py。</p><h2 id="设计的数据类型"><a href="#设计的数据类型" class="headerlink" title="设计的数据类型"></a>设计的数据类型</h2><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>由Spider生成最后由Downloader执行的的HTTP请求。</p><table><thead><tr><th>常用属性或方法</th><th>说明</th></tr></thead><tbody><tr><td>.url</td><td>Request对应的请求地址</td></tr><tr><td>.method</td><td>对应的请求方法，’GET’’POST’等</td></tr><tr><td>.headers</td><td>字典类型的请求头</td></tr><tr><td>.body</td><td>请求内容主体，字符串类型</td></tr><tr><td>.meta</td><td>用户添加信息的拓展信息位，在Scrapy内部模块间传递信息使用</td></tr><tr><td>.copy</td><td>复制该请求</td></tr></tbody></table><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>由Downloader生成最终给Spider处理的HTTP响应。</p><table><thead><tr><th>常用属性或方法</th><th>说明</th></tr></thead><tbody><tr><td>.url</td><td>Response对应的请求地址</td></tr><tr><td>.status</td><td>HTTP状态码，值是200说明成功接受</td></tr><tr><td>.headers</td><td>Response对应的头部信息</td></tr><tr><td>.body</td><td>Response对应的内容信息，字符串类型</td></tr><tr><td>.flags</td><td>标记</td></tr><tr><td>.request</td><td>产生Response对应的Request对象</td></tr><tr><td>.copy()</td><td>复制该响应</td></tr></tbody></table><h3 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h3><p>由Spider从HTML页面中提取最终交给Item Pipeline处理的信息内容（字典类型）。</p><h2 id="信息提取方法"><a href="#信息提取方法" class="headerlink" title="信息提取方法"></a>信息提取方法</h2><ul><li>Beautiful Soup</li><li>lxml</li><li>re</li><li>XPath Selector</li><li>CSS Selector</li></ul><h4 id="CSS-Selector"><a href="#CSS-Selector" class="headerlink" title="CSS Selector"></a>CSS Selector</h4><p>CSS Selector是由W3C维护的一种信息提取方法。使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HTML&gt;.css(<span class="string">'a::attr(href)'</span>).extract() <span class="comment"># 通过标签名称(a)和标签属性(href)来得到对应的标签信息</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（十一）——Scrapy爬虫框架简介</title>
      <link href="/2020/02/07/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/02/07/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫（十一）——Scrapy爬虫框架简介"><a href="#Python爬虫（十一）——Scrapy爬虫框架简介" class="headerlink" title="Python爬虫（十一）——Scrapy爬虫框架简介"></a>Python爬虫（十一）——Scrapy爬虫框架简介</h1><p>scrapy不是一个简单的功能库，而是一个功能强大的网络爬虫框架。它是实现爬虫功能的一个软件结构和功能组件集合。它约束了一个模板，用户用这个模板来实现爬虫。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开cmd执行一下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br><span class="line">scrapy -h</span><br></pre></td></tr></table></figure><p>成功后：</p><p><img src="/2020/02/07/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/success.png" alt="success" title="success"></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>Scrapy有七个结构：SPIDERS（入口）、ITEM PIPELINES（出口）、ENGINE（已实现）、SCHEDULER（已实现）、DOWNLOADER（已实现）和MIDDLEWARE、INTERNET。</p><p>在这7个结构中，主要有三条数据流：</p><ol><li><strong>SPIDERS-&gt;ENGINE-&gt;SCHEDULER</strong> 首先是Spider给EngineE提交请求Requests，然后Engine转发给Scheduler。</li><li><strong>SCHEDULER-&gt;EMGINE-&gt;DOWNLOADER-&gt;ENGINE-&gt;SPIDERS</strong> 首先是Scheduler向Engine提交网络爬取请求Requests，然后Engine通过中间件发送给Downloader，然后Downloader从Internet中爬取相关网页，然后将爬取内容封装成成响应对象Response再发送给Engine，最终到达Spider。</li><li><strong>SPIDERS-&gt;ENGINE-&gt;ITEM PIPELINES and SCHEDULER</strong> Spider处理从Downloader获得的响应后形成ITEMS和一个新的请求Requests，然后发送给Engine。然后Engine将Items发给Item Pipelines进行后期的数据处理，将Requests发送给Scheduler从而爬取新的信息。</li></ol><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="ENGINE-整个框架的核心"><a href="#ENGINE-整个框架的核心" class="headerlink" title="ENGINE 整个框架的核心"></a>ENGINE 整个框架的核心</h3><p>它的主要功能有：</p><ul><li>控制所有模块之间的数据流</li><li>根据条件触发事件</li></ul><h3 id="DOWNLOADER"><a href="#DOWNLOADER" class="headerlink" title="DOWNLOADER"></a>DOWNLOADER</h3><p>它的主要功能是获得一个请求然后爬取网页得到信息打包后返回。</p><h3 id="SCHEDULER-调度模块"><a href="#SCHEDULER-调度模块" class="headerlink" title="SCHEDULER 调度模块"></a>SCHEDULER 调度模块</h3><p>对所有的爬取请求进行调度管理，对这些请求进行排序。</p><h3 id="Downloader-Middleware"><a href="#Downloader-Middleware" class="headerlink" title="Downloader Middleware"></a>Downloader Middleware</h3><p>为了实施ENGINE、SCHDULER和DOWNLOADER之间的用户可配置的控制（修改、丢弃、新增请求或响应），设置了这个中间件。</p><h3 id="SPIDER"><a href="#SPIDER" class="headerlink" title="SPIDER"></a>SPIDER</h3><p>主要功能：</p><ul><li>解析Downloader返回的响应</li><li>产生爬取项</li><li>产生额外的爬取请求</li></ul><h3 id="Item-PIPELINES"><a href="#Item-PIPELINES" class="headerlink" title="Item PIPELINES"></a>Item PIPELINES</h3><p>以一组操作顺序组成，用流水线的方式处理Spider产生的爬取项（清理、检验和查重），最后将数据存储到数据库。</p><h3 id="Spider-MIDDLEWARE"><a href="#Spider-MIDDLEWARE" class="headerlink" title="Spider MIDDLEWARE"></a>Spider MIDDLEWARE</h3><p>为了请求和爬取项的再处理（修改、丢弃、新增请求或爬取项），设置了这个中间件</p><h2 id="requests库与scrapy库的比较"><a href="#requests库与scrapy库的比较" class="headerlink" title="requests库与scrapy库的比较"></a>requests库与scrapy库的比较</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>都可以进行页面请求和爬取</li><li>可用性都很好，文档丰富，入门简单</li><li>都没有处理js、提交表单、应对验证码等功能</li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><table><thead><tr><th>requests</th><th>Scrapy</th></tr></thead><tbody><tr><td>页面级爬虫</td><td>网站级爬虫</td></tr><tr><td>功能库</td><td>框架</td></tr><tr><td>并发性不足，性能差</td><td>并发性好，性能较好</td></tr><tr><td>重点在于页面下载</td><td>重点在于爬虫结构</td></tr><tr><td>定制灵活</td><td>一般定制灵活，深度定制困难</td></tr><tr><td>上手十分简单</td><td>入门稍难</td></tr></tbody></table><p><strong>注</strong>：网络爬虫的快慢只是一个简单的参数，在应对反爬机制时反而要求爬取速度较慢。小的程序适合使用requests库，而较大的适合Scrapy</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;scrapy &lt;command&gt; [options] [args]</span><br></pre></td></tr></table></figure><p>常用命令：</p><table><thead><tr><th>命令</th><th>说明</th><th>格式</th></tr></thead><tbody><tr><td><strong>startproject</strong></td><td>创建一个新工程</td><td>scrapy startproject &lt;name&gt; [dir]</td></tr><tr><td><strong>genspider</strong></td><td>创建一个爬虫</td><td>scrapy genspider [options] &lt;name&gt; &lt;domain&gt;</td></tr><tr><td>settings</td><td>获得爬虫配置信息</td><td>scrapy settings [options]</td></tr><tr><td><strong>crawl</strong></td><td>运行一个爬虫</td><td>scrapy crawl  &lt;spider&gt;</td></tr><tr><td>list</td><td>列出工程中所有爬虫</td><td>scrapy list</td></tr><tr><td>shell</td><td>启动URL调试命令行</td><td>scrapy shell [url]</td></tr></tbody></table><p>使用命令行是为了自动化操作，易于脚本控制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（十）——股票定向爬虫</title>
      <link href="/2020/02/06/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/"/>
      <url>/2020/02/06/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫（十）——股票定向爬虫"><a href="#Python爬虫（十）——股票定向爬虫" class="headerlink" title="Python爬虫（十）——股票定向爬虫"></a>Python爬虫（十）——股票定向爬虫</h1><ul><li>目标：获取上交所和深交所的所有股票的名称和交易信息</li><li>输出：保存到文件中</li><li>技术路线：requests-bs4-re<a id="more"></a></li></ul><h2 id="候选网站"><a href="#候选网站" class="headerlink" title="候选网站"></a>候选网站</h2><blockquote><p>新浪股票：<a href="http://finance.sina.com.cn/stock/" target="_blank" rel="noopener">http://finance.sina.com.cn/stock/</a></p></blockquote><blockquote><p>百度股票：<a href="http://gupiao.baidu.com/stock/" target="_blank" rel="noopener">http://gupiao.baidu.com/stock/</a></p></blockquote><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><ul><li>选取原则：股票信息静态存在于HTML页面中，非js代码生成，没有Robots协议限制。</li><li>选取方法：通过开发者模式或查看源代码。</li><li>选取心态：多找几个网站尝试。</li></ul><p>因此我们观察新浪的网页代码，发现股票的信息都是引用的js代码，然后百度股票已经关闭了网页版。所以我们在查阅了其他各种股票网站以后选择了中财网这个网站（<a href="http://quote.cfi.cn/）。" target="_blank" rel="noopener">http://quote.cfi.cn/）。</a></p><h2 id="程序的结构设计"><a href="#程序的结构设计" class="headerlink" title="程序的结构设计"></a>程序的结构设计</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>从东方财富网获取股票列表</li><li>根据股票列表逐个到中财网获取个股信息</li><li>将结果存储到文件</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="getHTMLText-url-code-’utf-8’"><a href="#getHTMLText-url-code-’utf-8’" class="headerlink" title="getHTMLText(url, code=’utf-8’)"></a>getHTMLText(url, code=’utf-8’)</h4><p>在这里我们预设encoding为’utf-8’从而节省判断编码的时间。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url, code=<span class="string">'utf-8'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = code  <span class="comment"># 判断编码时间会消耗很多时间，所以我们提前去网站上了解编码类型</span></span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><h4 id="getStockList-lst-stockUrl"><a href="#getStockList-lst-stockUrl" class="headerlink" title="getStockList(lst, stockUrl)"></a>getStockList(lst, stockUrl)</h4><p>我们先得到股票列表。通过观察网页源代码，我们发现上证和深证的股票编码可以用以下的正则表达式表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">r'[s][hz]\d&#123;6&#125;'</span></span><br></pre></td></tr></table></figure><p>然后我们查询网站的编码类型：</p><p><img src="/2020/02/06/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/dfcharset.png" alt="编码类型" title="编码类型"></p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStockList</span><span class="params">(lst, stockUrl)</span>:</span></span><br><span class="line">    html = getHTMLText(stockUrl, <span class="string">'GB2312'</span>)  <span class="comment"># 填上在网页代码中看到的编码方式</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">    a = soup.find_all(<span class="string">'a'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            href = i.attrs[<span class="string">'href'</span>]</span><br><span class="line">            lst.append(re.findall(<span class="string">r'[s][hz]\d&#123;6&#125;'</span>, href)[<span class="number">0</span>][<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h4 id="getStockInfo-lst-stockUrl"><a href="#getStockInfo-lst-stockUrl" class="headerlink" title="getStockInfo(lst, stockUrl)"></a>getStockInfo(lst, stockUrl)</h4><p>最后我们对股票列表中的股票进行查询后提取股票的信息。这时我们需要在网页代码中找到我们需要的信息。我们发现整个股票的信息都在一个table中：</p><p><img src="/2020/02/06/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/table.png" alt="tabel" title="table"></p><p>进一步观察发现股票名字在一个class=’Lfont’的标签中：</p><p><img src="/2020/02/06/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/Lfont.png" alt="Lfont" title="Lfont"></p><p>而其他的信息都在一个class=’Rlist’的标签中：</p><p><img src="/2020/02/06/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/Rlist.png" alt="Rlist" title="Rlist"></p><p>在充分了解相关信息的name和attrs后，我们利用BeautifulSoup提取出相关信息再将其存入excel表格中。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStockInfo</span><span class="params">(lst, stockUrl)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    wb = xlwt.Workbook(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    ws = wb.add_sheet(<span class="string">'股票'</span>)</span><br><span class="line">    ws.write(<span class="number">0</span>, <span class="number">0</span>, label=<span class="string">'股票名称'</span>)</span><br><span class="line">    ws.write(<span class="number">0</span>, <span class="number">1</span>, label=<span class="string">'信息'</span>)</span><br><span class="line">    <span class="keyword">for</span> stock <span class="keyword">in</span> lst:</span><br><span class="line">        url = stockUrl+stock+<span class="string">'.html'</span>  <span class="comment"># 得到每个股票代码的网页</span></span><br><span class="line">        html = getHTMLText(url)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> html == <span class="string">""</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            infoDict = &#123;&#125;</span><br><span class="line">            soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">            stockInfo = soup.find(<span class="string">'table'</span>, attrs=&#123;</span><br><span class="line">                                  <span class="string">'style'</span>: <span class="string">'width:550px;border:0;padding:0;border-collapse:collapse;'</span>&#125;)</span><br><span class="line">            <span class="keyword">if</span> stockInfo:</span><br><span class="line">                name = stockInfo.find(<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'Lfont'</span>&#125;)</span><br><span class="line">                infoDict.update(&#123;<span class="string">'股票名称'</span>: name.text&#125;)</span><br><span class="line">                table = stockInfo.find(<span class="string">'td'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'Rlist'</span>&#125;)</span><br><span class="line">                keyList = table.find_all(<span class="string">'td'</span>)</span><br><span class="line">                key = <span class="string">''</span></span><br><span class="line">                <span class="keyword">for</span> td <span class="keyword">in</span> keyList:</span><br><span class="line">                    key = key+(td.text+<span class="string">'\n'</span>)</span><br><span class="line">                infoDict[<span class="string">'信息'</span>] = key</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                ws.write(count, <span class="number">0</span>, label=infoDict[<span class="string">'股票名称'</span>])</span><br><span class="line">                ws.write(count, <span class="number">1</span>, label=infoDict[<span class="string">'信息'</span>])</span><br><span class="line">                print(<span class="string">'\r当前进度：&#123;:.2f&#125;&amp;'</span>.format(count*<span class="number">100</span>/len(lst)),</span><br><span class="line">                      end=<span class="string">''</span>)  <span class="comment"># /r能够将打印的光标提到行首</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'\r当前进度：&#123;:.2f&#125;&amp;'</span>.format(count*<span class="number">100</span>/len(lst)), end=<span class="string">''</span>)</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    wb.save(<span class="string">'股票.xls'</span>)</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url, code=<span class="string">'utf-8'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = code  <span class="comment"># 判断编码时间会消耗很多时间，所以我们提前去网站上了解编码类型</span></span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStockList</span><span class="params">(lst, stockUrl)</span>:</span></span><br><span class="line">    html = getHTMLText(stockUrl, <span class="string">'GB2312'</span>)  <span class="comment"># 填上在网页代码中看到的编码方式</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">    a = soup.find_all(<span class="string">'a'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            href = i.attrs[<span class="string">'href'</span>]</span><br><span class="line">            lst.append(re.findall(<span class="string">r'[s][hz]\d&#123;6&#125;'</span>, href)[<span class="number">0</span>][<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStockInfo</span><span class="params">(lst, stockUrl)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    wb = xlwt.Workbook(encoding=<span class="string">'utf-8'</span>) <span class="comment"># 新建一个workbook</span></span><br><span class="line">    ws = wb.add_sheet(<span class="string">'股票'</span>) <span class="comment"># 新建一个worksheet</span></span><br><span class="line">    ws.write(<span class="number">0</span>, <span class="number">0</span>, label=<span class="string">'股票名称'</span>)</span><br><span class="line">    ws.write(<span class="number">0</span>, <span class="number">1</span>, label=<span class="string">'信息'</span>)</span><br><span class="line">    <span class="keyword">for</span> stock <span class="keyword">in</span> lst:</span><br><span class="line">        url = stockUrl+stock+<span class="string">'.html'</span>  <span class="comment"># 得到每个股票代码的网页</span></span><br><span class="line">        html = getHTMLText(url)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> html == <span class="string">""</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            infoDict = &#123;&#125;</span><br><span class="line">            soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">            stockInfo = soup.find(<span class="string">'table'</span>, attrs=&#123;</span><br><span class="line">                                  <span class="string">'style'</span>: <span class="string">'width:550px;border:0;padding:0;border-collapse:collapse;'</span>&#125;)</span><br><span class="line">            <span class="keyword">if</span> stockInfo:</span><br><span class="line">                name = stockInfo.find(<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'Lfont'</span>&#125;)</span><br><span class="line">                infoDict.update(&#123;<span class="string">'股票名称'</span>: name.text&#125;)</span><br><span class="line">                table = stockInfo.find(<span class="string">'td'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'Rlist'</span>&#125;)</span><br><span class="line">                keyList = table.find_all(<span class="string">'td'</span>)</span><br><span class="line">                key = <span class="string">''</span></span><br><span class="line">                <span class="keyword">for</span> td <span class="keyword">in</span> keyList:</span><br><span class="line">                    key = key+(td.text+<span class="string">'\n'</span>)</span><br><span class="line">                infoDict[<span class="string">'信息'</span>] = key</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                ws.write(count, <span class="number">0</span>, label=infoDict[<span class="string">'股票名称'</span>]) <span class="comment"># 写入信息</span></span><br><span class="line">                ws.write(count, <span class="number">1</span>, label=infoDict[<span class="string">'信息'</span>]) <span class="comment"># 写入信息</span></span><br><span class="line">                print(<span class="string">'\r当前进度：&#123;:.2f&#125;&amp;'</span>.format(count*<span class="number">100</span>/len(lst)),</span><br><span class="line">                      end=<span class="string">''</span>)  <span class="comment"># /r能够将打印的光标提到行首</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'\r当前进度：&#123;:.2f&#125;&amp;'</span>.format(count*<span class="number">100</span>/len(lst)), end=<span class="string">''</span>)</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    wb.save(<span class="string">'股票.xls'</span>) <span class="comment"># 保存为股票.xls</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stockListUrl = <span class="string">'http://quote.eastmoney.com/stock_list.html'</span></span><br><span class="line">stockInfoUrl = <span class="string">'http://quote.cfi.cn/quote_'</span></span><br><span class="line">slist = []</span><br><span class="line">getStockList(slist, stockListUrl)</span><br><span class="line">getStockInfo(slist, stockInfoUrl, fpath)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2020/02/06/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/result.png" alt="result" title="result"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（九）——京东比价定向爬虫</title>
      <link href="/2020/02/05/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E4%BA%AC%E4%B8%9C%E6%AF%94%E4%BB%B7%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/"/>
      <url>/2020/02/05/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E4%BA%AC%E4%B8%9C%E6%AF%94%E4%BB%B7%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫（九）——京东比价定向爬虫"><a href="#Python爬虫（九）——京东比价定向爬虫" class="headerlink" title="Python爬虫（九）——京东比价定向爬虫"></a>Python爬虫（九）——京东比价定向爬虫</h1><ul><li>目标：获取淘宝搜索页面的信息，提取其中的商品名称和价格。</li><li>要求：淘宝的搜索接口 翻页的处理</li><li>技术路线：requests-re</li></ul><a id="more"></a><h2 id="判断可行性"><a href="#判断可行性" class="headerlink" title="判断可行性"></a>判断可行性</h2><h3 id="查看链接"><a href="#查看链接" class="headerlink" title="查看链接"></a>查看链接</h3><p>第一页：<br><a href="https://search.jd.com/Search?keyword=相机&amp;enc=utf-8&amp;page=1" target="_blank" rel="noopener">https://search.jd.com/Search?keyword=相机&amp;enc=utf-8&amp;page=1</a></p><p>第二页：<br><a href="https://search.jd.com/Search?keyword=相机&amp;enc=utf-8&amp;page=3" target="_blank" rel="noopener">https://search.jd.com/Search?keyword=相机&amp;enc=utf-8&amp;page=3</a></p><p>第三页：<br><a href="https://search.jd.com/Search?keyword=相机&amp;enc=utf-8&amp;page=5" target="_blank" rel="noopener">https://search.jd.com/Search?keyword=相机&amp;enc=utf-8&amp;page=5</a></p><p>由上我们可以猜测最后的s变量和页码有关。</p><h3 id="查看robots协议"><a href="#查看robots协议" class="headerlink" title="查看robots协议"></a>查看robots协议</h3><p>打开淘宝的robots.txt。发现：</p><p><img src="/2020/02/05/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E4%BA%AC%E4%B8%9C%E6%AF%94%E4%BB%B7%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/JDRobots.png" alt="京东robots协议" title="京东robots协议"></p><p>结果我们发现它不允许我们爬取。不过我们如果行为就像人类的行为，没有过度消耗服务器的资源仅仅是用于学习和探索那是没有问题的。</p><h2 id="程序的设计"><a href="#程序的设计" class="headerlink" title="程序的设计"></a>程序的设计</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>提交上屏搜索请求，循环获取页面</li><li>对于每个页面，提取商品名称和价格信息</li><li>将信息输出到屏幕上</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="def-getHTMLText-url"><a href="#def-getHTMLText-url" class="headerlink" title="def getHTMLText(url)"></a>def getHTMLText(url)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>: <span class="comment"># 利用前面的代码框架返回页面的text</span></span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding=r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p>这时我们发现无法得到结果，查看后发现界面跳转到了登录界面，于是我们加入cookies参数来解决这个问题。</p><p>那么如何得到cookie呢？我们打开这个网页，按下f12打开开发者模式：</p><p><img src="/2020/02/05/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E4%BA%AC%E4%B8%9C%E6%AF%94%E4%BB%B7%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/developer.png" alt="开发者模式" title="开发者模式"></p><p>然后选中network刷新一下界面，在最上面找到Search?keyword=这个包：</p><p><img src="/2020/02/05/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E4%BA%AC%E4%B8%9C%E6%AF%94%E4%BB%B7%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/searchpacket.png" alt="searchpacket" title="searchpacket"></p><p>然后我们在右边的Request Hearders中就能找到自己的cookie：</p><p><img src="/2020/02/05/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E4%BA%AC%E4%B8%9C%E6%AF%94%E4%BB%B7%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/request.png" alt="requestHeaders" title="requestHeaders"></p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 利用前面的代码框架返回页面的text</span></span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>, headers=&#123;<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36'</span>&#125;, cookies=&#123;</span><br><span class="line">                         <span class="string">'cookie'</span>: <span class="string">'你的cookie'</span>&#125;)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><h4 id="parsePage-ilt-html"><a href="#parsePage-ilt-html" class="headerlink" title="parsePage(ilt, html)"></a>parsePage(ilt, html)</h4><p>我们首先打开网页的源代码找到商品的信息。</p><p><img src="/2020/02/05/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E4%BA%AC%E4%B8%9C%E6%AF%94%E4%BB%B7%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/goodsInfo.png" alt="商品信息" title="商品信息"></p><p>我们发现淘宝商品的名字在标签em中且<strong>都有相机</strong>，而价格在标签i中且都是由<strong>数字.数字</strong>组成，于是利用以下两个正则表达式表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#价格</span></span><br><span class="line"><span class="string">r'\&lt;i\&gt;[\d]*\.[\d]*\&lt;\/i\&gt;'</span></span><br><span class="line"><span class="comment">#商品名称</span></span><br><span class="line"><span class="string">r'\&lt;em\&gt;.*相机.*\&lt;\/em\&gt;'</span></span><br></pre></td></tr></table></figure><p>那么方法的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(ilt, html)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 商品价格由数字和小数点组成所以用[\d.]*\.[\d]*来表示</span></span><br><span class="line">        plt = re.findall(<span class="string">r'\&lt;i\&gt;[\d]*\.[\d]*\&lt;\/i\&gt;'</span>, html)</span><br><span class="line">        tlt = re.findall(<span class="string">r'\&lt;em\&gt;.*相机.*\&lt;\/em\&gt;'</span>, html)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plt)):</span><br><span class="line">            price = plt[i][<span class="number">3</span>:<span class="number">-4</span>]  <span class="comment"># 直接利用python字符串特性得到价格</span></span><br><span class="line">            <span class="keyword">if</span> re.findall(<span class="string">r'.*京品数码.*'</span>, tlt[i]) <span class="keyword">or</span> re.findall(<span class="string">r'.*京东国际.*'</span>, tlt[i]) <span class="keyword">or</span> re.findall(<span class="string">r'.*京东超市.*'</span>, tlt[i]):</span><br><span class="line">                print(<span class="string">'here'</span>)</span><br><span class="line">                <span class="comment"># 通过最小匹配来得到第一个&lt;之前的内容</span></span><br><span class="line">                title = re.findall(<span class="string">r'span\&gt;.*?\&lt;'</span>, tlt[i])[<span class="number">0</span>][<span class="number">5</span>:<span class="number">-1</span>]+<span class="string">'相机'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 同样的方法获得其他类型商品名称</span></span><br><span class="line">                title = re.findall(<span class="string">r'em\&gt;.*?\&lt;'</span>, tlt[i])[<span class="number">0</span>][<span class="number">3</span>:<span class="number">-1</span>]+<span class="string">'相机'</span></span><br><span class="line">            ilt.append([price, title])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><h4 id="printGoodLists-ilt"><a href="#printGoodLists-ilt" class="headerlink" title="printGoodLists(ilt)"></a>printGoodLists(ilt)</h4><p>最后将结果打印出来，这里我也遇到了一些问题：<strong>无法打印出界面中所有的商品，我用BeautifulSoup+re分析也是同样的结果，如果你知道问题的所在希望能够给我留言或者私信我。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printGoodLists</span><span class="params">(ilt)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;"</span>  <span class="comment"># 给出打印模板，第一个长度为4，第二个长度为8，最后一个长度为16</span></span><br><span class="line">    print(tplt.format(<span class="string">"序号"</span>, <span class="string">"价格"</span>, <span class="string">"商品名称"</span>))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> goods <span class="keyword">in</span> ilt:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        print(tplt.format(count, goods[<span class="number">0</span>], goods[<span class="number">1</span>]))</span><br><span class="line">    print(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding='utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 利用前面的代码框架返回页面的text</span></span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>, headers=&#123;<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36'</span>&#125;, cookies=&#123;</span><br><span class="line">                         <span class="string">'cookie'</span>: <span class="string">'你的cookie'</span>&#125;)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(ilt, html)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 商品价格由数字和小数点组成所以用[\d.]*\.[\d]*来表示</span></span><br><span class="line">        plt = re.findall(<span class="string">r'\&lt;i\&gt;[\d]*\.[\d]*\&lt;\/i\&gt;'</span>, html)</span><br><span class="line">        tlt = re.findall(<span class="string">r'\&lt;em\&gt;.*相机.*\&lt;\/em\&gt;'</span>, html)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(plt)):</span><br><span class="line">            price = plt[i][<span class="number">3</span>:<span class="number">-4</span>]  <span class="comment"># 直接利用python字符串特性得到价格</span></span><br><span class="line">            <span class="keyword">if</span> re.findall(<span class="string">r'.*京品数码.*'</span>, tlt[i]) <span class="keyword">or</span> re.findall(<span class="string">r'.*京东国际.*'</span>, tlt[i]) <span class="keyword">or</span> re.findall(<span class="string">r'.*京东超市.*'</span>, tlt[i]):</span><br><span class="line">                <span class="comment"># 通过最小匹配来得到第一个&lt;之前的内容</span></span><br><span class="line">                title = re.findall(<span class="string">r'span\&gt;.*?\&lt;'</span>, tlt[i])[<span class="number">0</span>][<span class="number">5</span>:<span class="number">-1</span>]+<span class="string">'相机'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 同样的方法获得其他类型商品名称</span></span><br><span class="line">                title = re.findall(<span class="string">r'em\&gt;.*?\&lt;'</span>, tlt[i])[<span class="number">0</span>][<span class="number">3</span>:<span class="number">-1</span>]+<span class="string">'相机'</span></span><br><span class="line">            ilt.append([price, title])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printGoodLists</span><span class="params">(ilt)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;"</span>  <span class="comment"># 给出打印模板，第一个长度为4，第二个长度为8，最后一个长度为16</span></span><br><span class="line">    print(tplt.format(<span class="string">"序号"</span>, <span class="string">"价格"</span>, <span class="string">"商品名称"</span>))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> goods <span class="keyword">in</span> ilt:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        print(tplt.format(count, goods[<span class="number">0</span>], goods[<span class="number">1</span>]))</span><br><span class="line">    print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">goods = <span class="string">'相机'</span></span><br><span class="line">depth = <span class="number">3</span></span><br><span class="line">startUrl = <span class="string">'https://search.jd.com/Search?keyword='</span>+goods+<span class="string">'&amp;enc=utf-8'</span></span><br><span class="line">infoList = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(depth):  <span class="comment"># 这里通过循环来查询多个页面并保存再infoList中</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        page = i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        url = startUrl+<span class="string">'&amp;page='</span>+str(page)  <span class="comment"># 利用之前观察的页面url来设定每个页面的url</span></span><br><span class="line">        html = getHTMLText(url)</span><br><span class="line">        parsePage(infoList, html)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">printGoodLists(infoList)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/05/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E4%BA%AC%E4%B8%9C%E6%AF%94%E4%BB%B7%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB/result.png" alt="运行结果" title="运行结果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序设计语言（二）——标准输入输出</title>
      <link href="/2020/02/05/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2020/02/05/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="C-程序设计语言（二）——标准输入输出"><a href="#C-程序设计语言（二）——标准输入输出" class="headerlink" title="C++程序设计语言（二）——标准输入输出"></a>C++程序设计语言（二）——标准输入输出</h1><p>C++语言提供了iostream库来表示输入流和输出流。它包含两个基本类型istream和ostream，分别表示输入流和输出流。</p><p>流（stream），随着时间的推移，字符是顺序生成或消耗的。</p><a id="more"></a><h2 id="标准输入输出对象"><a href="#标准输入输出对象" class="headerlink" title="标准输入输出对象"></a>标准输入输出对象</h2><p>标准库定义了4个IO对象：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>cin</td><td>标准输入（standard input），从键盘读取数据</td></tr><tr><td>cout</td><td>标准输出（standard output），将信息打印到屏幕上</td></tr><tr><td>cerr</td><td>标准错误（standard error），通常用来输出警告和错误信息</td></tr><tr><td>clog</td><td>标准日志，用来输出程序运行时的一般性信息</td></tr></tbody></table><p>两个运算符：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>&lt;&lt;</td><td>输出运算符，左侧必须是一个ostream对象，右侧是要打印的值。作用是将右侧的晕眩对象写到左侧给定的ostream对象中，然后返回左侧运算对象作为计算结果</td></tr><tr><td>&gt;&gt;</td><td>输入运算符，左侧必须是一个istream对象，右侧接受一个对象作为运算对象。作用是从左侧istream读取数据然后存入右侧运算对象中，然后返回左侧运算对象作为计算结果</td></tr></tbody></table><h3 id="cout中的常用的方法"><a href="#cout中的常用的方法" class="headerlink" title="cout中的常用的方法"></a>cout中的常用的方法</h3><p><strong>.precision()设置小数点后有效数字</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">5</span>); <span class="comment">//小数点后保留五位</span></span><br></pre></td></tr></table></figure><p><strong>.fill()设置空白区域填充</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.<span class="built_in">fill</span>(<span class="string">"*"</span>); <span class="comment">//空白区域使用*填充</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.<span class="built_in">fill</span>(<span class="string">""</span>); <span class="comment">//切换为不填充</span></span><br></pre></td></tr></table></figure><p><strong>输出十六进制、十进制、八进制</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; oct &lt;&lt; n &lt;&lt; dec &lt;&lt; n &lt;&lt; hex &lt;&lt; n; <span class="comment">//依次以八进制、十进制、十六进制输出整数n</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.unsetf(ios::dec); <span class="comment">//切换进制需要先去除原先的进制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(ios::oct);</span><br></pre></td></tr></table></figure><p><strong>.width()设置输出宽度</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.<span class="built_in">width</span>(<span class="number">10</span>); <span class="comment">//设置输出宽度为10</span></span><br></pre></td></tr></table></figure><p><strong>格式标志</strong><br>常见标志：</p><table><thead><tr><th>标志</th><th>功能</th></tr></thead><tbody><tr><td>oct</td><td>以八进制输出数值</td></tr><tr><td>dec</td><td>以十进制输出数值</td></tr><tr><td>hex</td><td>以十六进制输出数值</td></tr><tr><td>left</td><td>输出调整为左对齐</td></tr><tr><td>right</td><td>输出调整为右对齐</td></tr><tr><td>scientific</td><td>用科学计数法显示浮点数</td></tr><tr><td>fixed</td><td>用正常的计数方法显示浮点数</td></tr><tr><td>showbase</td><td>输出时显示所有数值的基数</td></tr><tr><td>showpoint</td><td>显示小数点和额外的零</td></tr><tr><td>showpos</td><td>在数值前显示正负号</td></tr><tr><td>skipws</td><td>当从一个流进行读取时，跳过空白字符</td></tr><tr><td>unitbuf</td><td>每次插入后，清空缓冲区</td></tr><tr><td>uppercase</td><td>以大写的形式显示科学计数法中的”e”和十六进制格式的”x”</td></tr></tbody></table><p>格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.right;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::right);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::scientific);</span><br></pre></td></tr></table></figure><h4 id="iomanip库在输出格式中的应用"><a href="#iomanip库在输出格式中的应用" class="headerlink" title="iomanip库在输出格式中的应用"></a>iomanip库在输出格式中的应用</h4><p>利用setiosflags()算子设置标志：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setiosflags(<span class="built_in">std</span>::ios::scientific|<span class="built_in">std</span>::ios::showpos) &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（八）——正则表达式</title>
      <link href="/2020/02/04/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/02/04/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫（八）——正则表达式"><a href="#Python爬虫（八）——正则表达式" class="headerlink" title="Python爬虫（八）——正则表达式"></a>Python爬虫（八）——正则表达式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>正则表达式（regular expression，RE）是一种通用的字符表达框架，用来简洁表达一组字符串的表达式。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>表达文本类型的特征</li><li>查找或替换一组字符串</li><li>匹配字符串的全部或部分</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>将符合正则表达式语法的字符串转换成正则表达式。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>正则表达式由字符和操作符构成</p><h3 id="常用操作符"><a href="#常用操作符" class="headerlink" title="常用操作符"></a>常用操作符</h3><table><thead><tr><th>操作符</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>.</td><td>表示任何单个字符</td><td></td></tr><tr><td>[]</td><td>字符集，对单个字符给出取值范围</td><td>[abc]表示a、b、c，[a-z]表示a到z单个字符</td></tr><tr><td>[^]</td><td>非字符集，对单个字符给出排除范围</td><td>[^abc]表示非a或b或c的单个字符</td></tr><tr><td>*</td><td>克林闭包</td><td></td></tr><tr><td>+</td><td>正闭包</td><td></td></tr><tr><td>?</td><td>前一个字符0次或1次拓展</td><td>a?表示Φ或a</td></tr><tr><td>|</td><td>左右表达式任意一个</td><td>ab|de表示ab或de</td></tr><tr><td>{m}</td><td>扩展前一个字符m次</td><td>ab{2}c表示abbc</td></tr><tr><td>{m,n}</td><td>扩展前一个字符m至n次（包含n）</td><td>ab{1,2}c表示abc或abbc</td></tr><tr><td>^</td><td>匹配字符串开头</td><td>^abc表示abc且abc在字符串的开头</td></tr><tr><td>$</td><td>匹配字符串结尾</td><td>abc$表示abc且abc在字符串的结尾</td></tr><tr><td>()</td><td>分组标记，内部只能使用</td><td>操作符(abc)表示abc，(abc|def)表示abc或def</td></tr><tr><td>\d</td><td>数字，等价于[0-9]</td><td></td></tr><tr><td>\w</td><td>单词字符，等价于[A-Za-z0-9]</td><td></td></tr></tbody></table><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>Re库是Python的标准库，主要用于字符串匹配。它使用raw string类型表示正则表达式。</p><p>调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><p>raw string不包含转义符，只用在普通string类型的字符串之前加上r就可。它也可使用string类型。</p><h3 id="主要功能函数"><a href="#主要功能函数" class="headerlink" title="主要功能函数"></a>主要功能函数</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>.search()</td><td>在一个字符串中搜索匹配正则表达式的第一个位置，返回一个match对象</td></tr><tr><td>.match()</td><td>从一个字符串的开始位置起匹配正则表达式，返回match对象</td></tr><tr><td>.findall()</td><td>搜索字符串，以列表类型返回全部能匹配的字符串</td></tr><tr><td>.split()</td><td>将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td></tr><tr><td>.finditer()</td><td>搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象</td></tr><tr><td>.sub()</td><td>在于给字符串中替换所有匹配正则表达式的子串，返回代替后的字符串</td></tr></tbody></table><h4 id="search-pattern-string-flags-0"><a href="#search-pattern-string-flags-0" class="headerlink" title=".search(pattern,string,flags=0)"></a>.search(pattern,string,flags=0)</h4><ul><li>pattern<br>正则表达式的字符串或原生字符串表示</li><li>string<br>待匹配字符串</li><li>flags 使用标记<ul><li>re.I/re.IGNORECASE<br>忽略正则表达式的大小写</li><li>re.M/re.MULTILINE<br>正则表达式中的^操作符能够将给定字符串的每行当作匹配开始</li><li>re.S/re.DOTALL<br>正则表达式中的.操作符能够匹配所有字符</li></ul></li></ul><h4 id="match-pattern-string-flags-0"><a href="#match-pattern-string-flags-0" class="headerlink" title=".match(pattern,string,flags=0)"></a>.match(pattern,string,flags=0)</h4><p>参数和search方法相同</p><h4 id="findall-pattern-string-flags-0"><a href="#findall-pattern-string-flags-0" class="headerlink" title=".findall(pattern,string,flags=0)"></a>.findall(pattern,string,flags=0)</h4><p>参数和search方法相同</p><h4 id="split-pattern-sting-maxsplit-0-flags-0"><a href="#split-pattern-sting-maxsplit-0-flags-0" class="headerlink" title=".split(pattern,sting,maxsplit=0,flags=0)"></a>.split(pattern,sting,maxsplit=0,flags=0)</h4><ul><li>maxsplit<br>最大分割数（<strong>匹配次数</strong>），剩余部分作为最后一个元素输出</li></ul><h4 id="finditer-pattern-string-flags-0"><a href="#finditer-pattern-string-flags-0" class="headerlink" title=".finditer(pattern,string,flags=0)"></a>.finditer(pattern,string,flags=0)</h4><p>参数和search方法相同</p><h4 id="sub-pattern-repl-string-count-0-flags-0"><a href="#sub-pattern-repl-string-count-0-flags-0" class="headerlink" title=".sub(pattern,repl,string,count=0,flags=0)"></a>.sub(pattern,repl,string,count=0,flags=0)</h4><ul><li>repl<br>替换匹配字符串的字符串</li><li>count<br>最大替换次数</li></ul><h3 id="两种用法"><a href="#两种用法" class="headerlink" title="两种用法"></a>两种用法</h3><p>函数式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rst = re.search(pattern,string,flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>面向对象式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pat = re.compile(pattern,flags=<span class="number">0</span>)</span><br><span class="line">rest = pat.search(string)</span><br></pre></td></tr></table></figure><h4 id="complie-pattern-flags-0"><a href="#complie-pattern-flags-0" class="headerlink" title=".complie(pattern,flags=0)"></a>.complie(pattern,flags=0)</h4><p>将正则表达式的字符串形式编译成正则表达式对象</p><ul><li>pattern<br>正则表达式的字符串或原生字符串表示</li><li>flags 使用标记<ul><li>re.I/re.IGNORECASE<br>忽略正则表达式的大小写</li><li>re.M/re.MULTILINE<br>正则表达式中的^操作符能够将给定字符串的每行当作匹配开始</li><li>re.S/re.DOTALL<br>正则表达式中的.操作符能够匹配所有字符</li></ul></li></ul><p>我们要清楚字符串和原生字符串表示并不是正则表达式，只有当使用compile方法返回的对象才是正则表达式。这个对象也有以上六种方法。</p><h2 id="match对象"><a href="#match对象" class="headerlink" title="match对象"></a>match对象</h2><p>match对象是一次匹配的结果，包含了匹配的信息。</p><h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>.string</td><td>待匹配的文本</td></tr><tr><td>.re</td><td>匹配时使用的pattern对象</td></tr><tr><td>.pos</td><td>正则表达式搜索文本的开始位置</td></tr><tr><td>.endpos</td><td>正则表达式搜索文本的结束位置</td></tr></tbody></table><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>.group(0)</td><td>获得匹配后的字符串</td></tr><tr><td>.start()</td><td>匹配字符串在原始字符串的开始位置</td></tr><tr><td>.end()</td><td>匹配字符串在原始字符串的结束位置</td></tr></tbody></table><h2 id="贪婪匹配和最小匹配"><a href="#贪婪匹配和最小匹配" class="headerlink" title="贪婪匹配和最小匹配"></a>贪婪匹配和最小匹配</h2><h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>Re库的默认匹配方式，输出匹配最长的字串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match = re.search(<span class="string">r'PY.*N'</span>, <span class="string">'PYANBNCNDN'</span>)</span><br></pre></td></tr></table></figure><h3 id="最小匹配"><a href="#最小匹配" class="headerlink" title="最小匹配"></a>最小匹配</h3><p>输出最短的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match = re.search(<span class="string">r'PY.*?N'</span>, <span class="string">'PYANBNCNDN'</span>)</span><br></pre></td></tr></table></figure><h4 id="最小匹配操作符"><a href="#最小匹配操作符" class="headerlink" title="最小匹配操作符"></a>最小匹配操作符</h4><p><strong>注</strong>：这里都是前一个字符</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>前一个字符克林闭包的最小匹配</td></tr><tr><td>+?</td><td>前一个字符正闭包的最小匹配</td></tr><tr><td>??</td><td>前一个字符0次或1次拓展的最小匹配</td></tr><tr><td>{m,n}?</td><td>扩展前一个字符m至n次（含n次）的最小匹配</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序设计语言（一）——概览</title>
      <link href="/2020/02/04/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A6%82%E8%A7%88/"/>
      <url>/2020/02/04/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="C-程序设计语言（一）——概览"><a href="#C-程序设计语言（一）——概览" class="headerlink" title="C++程序设计语言（一）——概览"></a>C++程序设计语言（一）——概览</h1><p>C++是一种被广泛使用的计算机程序设计语言。它是一种通用程序设计语言，支持多重编程模式，例如过程化程序设计、数据抽象、面向对象程序设计、泛型程序设计和设计模式等。——引自维基百科</p><a id="more"></a><h2 id="C-的编程范式-Programming-Paradigm"><a href="#C-的编程范式-Programming-Paradigm" class="headerlink" title="C++的编程范式(Programming Paradigm)"></a>C++的编程范式(Programming Paradigm)</h2><h3 id="结构化编程-Structural-Programming"><a href="#结构化编程-Structural-Programming" class="headerlink" title="结构化编程(Structural Programming)"></a>结构化编程(Structural Programming)</h3><p>它采用子程序、代码区块、for循环以及while循环等结构，来取代传统的 goto从而改善计算机程序的明晰性、质量以及开发时间，并且避免写出面条式代码。</p><h3 id="Object-Oriented-Programming-OOP-面向对象编程"><a href="#Object-Oriented-Programming-OOP-面向对象编程" class="headerlink" title="Object-Oriented Programming(OOP,面向对象编程)"></a>Object-Oriented Programming(OOP,面向对象编程)</h3><p>在面向对象编程中，每个对象想要访问其他对象的数据都需要通过接口，它是程序更加容易开发和维护。</p><h3 id="Generic-Programming-GP-泛型编程"><a href="#Generic-Programming-GP-泛型编程" class="headerlink" title="Generic Programming(GP,泛型编程)"></a>Generic Programming(GP,泛型编程)</h3><p>它通过模板定义一种通用的类型，让编译器自动处理数据类型，节省了程序员的工作。</p><h3 id="Functional-Programming-FP-函数式编程"><a href="#Functional-Programming-FP-函数式编程" class="headerlink" title="Functional Programming(FP,函数式编程)"></a>Functional Programming(FP,函数式编程)</h3><p>在2011年后C++引入了lambda表达式。它的结果不会受到外部状态改变的影响，不论在任何时候结果都唯一。此外他也可以接受函数作为输入或输出。</p><h4 id="函数副作用"><a href="#函数副作用" class="headerlink" title="函数副作用"></a>函数副作用</h4><p>函数副作用是指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。副作用的函数不仅仅只是返回了一个值，而且还做了其他的事情，比如：</p><ol><li>修改了一个变量</li><li>直接修改数据结构</li><li>设置一个对象的成员</li><li>抛出一个异常或以一个错误终止</li><li>打印到终端或读取用户输入</li><li>读取或写入一个文件</li><li>在屏幕上画图</li></ol><p>函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误，并且降低程序的可读性，严格的函数式语言要求函数必须无副作用。</p><h5 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h5><p>输入输出数据流全是显式（Explicit）的。</p><p>显式的意思是，函数与外界交换数据只有一个唯一渠道——参数和返回值；函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过返回值传递到该函数外部。</p><h5 id="非纯函数"><a href="#非纯函数" class="headerlink" title="非纯函数"></a>非纯函数</h5><p>函数通过参数和返回值以外的渠道，和外界进行数据交换（隐式（Implicit）的方式）。</p><p>比如：读取全局变量、修改全局变量、利用 I/O API（输入输出系统函数库）读取配置文件、输出到文件、打印到屏幕。</p><h2 id="语言演化和标准"><a href="#语言演化和标准" class="headerlink" title="语言演化和标准"></a>语言演化和标准</h2><p>C++由C语言进化而来，参考了SMALL TALK语言，影响了Java语言和C#语言。C++11参考了python语言。</p><p><img src="/2020/02/04/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A6%82%E8%A7%88/evolution.png" alt="evolution" title="evolution"></p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="Visual-Studio集成开发环境"><a href="#Visual-Studio集成开发环境" class="headerlink" title="Visual Studio集成开发环境"></a>Visual Studio集成开发环境</h3><p>对于Visual Studio的安装已经有很多介绍了。（传送门：<a href="https://blog.csdn.net/qq_36556893/article/details/88603729）" target="_blank" rel="noopener">https://blog.csdn.net/qq_36556893/article/details/88603729）</a></p><p>这里推荐几个插件：</p><h4 id="Viasfora"><a href="#Viasfora" class="headerlink" title="Viasfora"></a>Viasfora</h4><p>该扩展可以使程序中的成对匹配的大中小括号以不同的颜色显示，便于我们将括号的左右半边匹配。</p><h4 id="Word-Highlight-With-Margin"><a href="#Word-Highlight-With-Margin" class="headerlink" title="Word Highlight With Margin"></a>Word Highlight With Margin</h4><p>当你用鼠标选中某个单词/标识符后，该扩展可以将所有的单词/标识符同时加亮显示。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（七）——中国大学排名爬虫</title>
      <link href="/2020/02/03/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D%E7%88%AC%E8%99%AB/"/>
      <url>/2020/02/03/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫（七）——中国大学排名定向爬虫"><a href="#Python爬虫（七）——中国大学排名定向爬虫" class="headerlink" title="Python爬虫（七）——中国大学排名定向爬虫"></a>Python爬虫（七）——中国大学排名定向爬虫</h1><p>我们将使用上海交大开发的软科排名。网站：</p><blockquote><p><a href="http://www.zuihaodaxue.com/BCSR/ruanjiangongcheng2019.html" target="_blank" rel="noopener">http://www.zuihaodaxue.com/BCSR/ruanjiangongcheng2019.html</a></p></blockquote><p>我们的目的是从这个网页中提取出2019年中国软件工程学科的排名、大学名称和总分。我们将会使用requests和bs4库。</p><a id="more"></a><h2 id="确定爬虫是否可行"><a href="#确定爬虫是否可行" class="headerlink" title="确定爬虫是否可行"></a>确定爬虫是否可行</h2><p>首先我们打开这个网站查看网站源代码。</p><p><img src="/2020/02/03/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D%E7%88%AC%E8%99%AB/wangyedaima.png" alt="网页代码" title="网页代码"></p><p>发现里面有我们要的信息。然后查看网站的robots.txt，发现没有这个文件，因此我们爬取信息是合法的。</p><h2 id="设计程序的结构"><a href="#设计程序的结构" class="headerlink" title="设计程序的结构"></a>设计程序的结构</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>整个过程可以分为三步</p><ol><li>从网络上获取大学排名网页内容，方法get_HTML_text()</li><li>提取网页内容中信息到合适的数据结构中，方法fill_univ_list()</li><li>利用数据结构展示结果，方法print_univ_list()</li></ol><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="模块的引入"><a href="#模块的引入" class="headerlink" title="模块的引入"></a>模块的引入</h3><p>我们使用requests库和bs4库，代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br></pre></td></tr></table></figure><h3 id="get-HTML-text"><a href="#get-HTML-text" class="headerlink" title="get_HTML_text()"></a>get_HTML_text()</h3><p>输入为网页链接，输出为网页内容<br>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_HTML_text</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>: <span class="comment">#使用之前的代码框架返回html</span></span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status() <span class="comment">#如果出现异常返回空字符串</span></span><br><span class="line">        r.encoding=r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><h3 id="fill-univ-list"><a href="#fill-univ-list" class="headerlink" title="fill_univ_list()"></a>fill_univ_list()</h3><p>输入为网页内容，然后将排名信息写入列表中。我们先观察网页HTML代码中的规律。</p><p><img src="/2020/02/03/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D%E7%88%AC%E8%99%AB/fill_univ_list.png" alt="规律" title="规律"></p><p>我们发现整个排名在tbody中，每个大学都在一个tr中，每个信息在td中。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_univ_list</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)  <span class="comment">#解析网页代码</span></span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>):</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag) <span class="keyword">and</span> len(tr(<span class="string">'td'</span>)) == <span class="number">7</span>:  <span class="comment">#检测标签的类型，过滤不是bs4中定义的Tag类型，这里需要引用bs4库</span></span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">3</span>].string, tds[<span class="number">6</span>].string]) <span class="comment">#注意排名、大学名称和分数在第几个</span></span><br></pre></td></tr></table></figure><h3 id="print-univ-list"><a href="#print-univ-list" class="headerlink" title="print_univ_list()"></a>print_univ_list()</h3><p>输入为排名的列表，然后打印出来。这里使用.format()格式化输出。为了保证对齐我们使用中文字符填充。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_univ_list</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:&#123;3&#125;^10&#125;\t&#123;1:&#123;4&#125;^10&#125;\t&#123;2:&#123;5&#125;^10&#125;"</span>  <span class="comment">#定义一个输出模板的变量</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>), chr(<span class="number">12288</span>), chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(<span class="string">" "</span>+tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>), chr(<span class="number">12288</span>), chr(<span class="number">12288</span>)))</span><br></pre></td></tr></table></figure><h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_HTML_text</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment">#使用之前的代码框架返回html</span></span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()  <span class="comment">#如果出现异常返回空字符串</span></span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_univ_list</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)  <span class="comment">#解析网页代码</span></span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>):</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag) <span class="keyword">and</span> len(tr(<span class="string">'td'</span>)) == <span class="number">7</span>:  <span class="comment">#检测标签的类型，过滤不是bs4中定义的Tag类型，这里需要引用bs4库</span></span><br><span class="line">            tds = tr(<span class="string">'td'</span>)</span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">3</span>].string, tds[<span class="number">6</span>].string])  <span class="comment">#注意排名、大学名称和分数在第几个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_univ_list</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:&#123;3&#125;^10&#125;\t&#123;1:&#123;4&#125;^10&#125;\t&#123;2:&#123;5&#125;^10&#125;"</span>  <span class="comment">#定义一个输出模板的变量</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>), chr(<span class="number">12288</span>), chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(<span class="string">" "</span>+tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>), chr(<span class="number">12288</span>), chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uinfo = []</span><br><span class="line">url = <span class="string">'http://www.zuihaodaxue.com/BCSR/ruanjiangongcheng2019.html'</span></span><br><span class="line">html = get_HTML_text(url)</span><br><span class="line">fill_univ_list(uinfo, html)</span><br><span class="line">print_univ_list(uinfo, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（六）——信息组织和提取</title>
      <link href="/2020/02/03/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E4%BF%A1%E6%81%AF%E7%BB%84%E7%BB%87%E5%92%8C%E6%8F%90%E5%8F%96/"/>
      <url>/2020/02/03/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E4%BF%A1%E6%81%AF%E7%BB%84%E7%BB%87%E5%92%8C%E6%8F%90%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫（六）——信息组织和提取"><a href="#Python爬虫（六）——信息组织和提取" class="headerlink" title="Python爬虫（六）——信息组织和提取"></a>Python爬虫（六）——信息组织和提取</h1><a id="more"></a><h2 id="信息的标记"><a href="#信息的标记" class="headerlink" title="信息的标记"></a>信息的标记</h2><p>对一组相关的信息进行标记有以下优点：</p><ul><li>可形成信息组织结构，增加了信息维度</li><li>可用于信息、存储或展示</li><li>标记的结构与信息一样具有重要价值</li><li>更利于程序理解和运用</li></ul><h3 id="信息标记的种类"><a href="#信息标记的种类" class="headerlink" title="信息标记的种类"></a>信息标记的种类</h3><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a><a href="https://www.w3school.com.cn/xml/index.asp" target="_blank" rel="noopener" title="w3school XML">XML</a></h4><p>eXtensible Markup Language，是基于HTML发展而来的一种通用的信息表达格式。用尖括号和标签表达信息的标记形式。最早的通用信息标记语言，可拓展性好，但繁琐。通常在Internet上交互和传递。</p><p>实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">school</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>BUPT<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">city</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">street</span>&gt;</span>北京市西土城路10号<span class="tag">&lt;/<span class="name">street</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zipcode</span>&gt;</span>100876<span class="tag">&lt;/<span class="name">zipcode</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">school</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a><a href="https://www.w3school.com.cn/json/index.asp" target="_blank" rel="noopener" title="w3school JSON">JSON</a></h4><p>JavaScript Object Notation，它由有类型的键值对组成。对于JavaScript等语言来说处理JSON格式很方便。信息有类型，适合程序处理（js），较XML简洁。移动应用云端和节点的通信，一般应用于程序在接口的地方，但无注释。</p><p>实例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"BUPT"</span>,</span><br><span class="line">    <span class="attr">"address"</span>: &#123;</span><br><span class="line">        <span class="attr">"city"</span>: <span class="string">"北京市"</span>,</span><br><span class="line">        <span class="attr">"street"</span>: <span class="string">"北京市西土城路10号"</span>,</span><br><span class="line">        <span class="attr">"zipcode"</span>: <span class="number">100876</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a><a href="https://yaml.org/" target="_blank" rel="noopener" title="official website">YAML</a></h4><p>YAML Ain’t Markup Language，它由无类型的键值对组成，它利用缩进来表示所属，用减号表示并列关系。信息无类型，文本信息比例最高，可读性好。应用于各类系统的配置文件中。</p><p>实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"name":</span> <span class="string">"BUPT"</span><span class="string">，</span></span><br><span class="line"><span class="attr">"address":</span> </span><br><span class="line">    <span class="attr">"city":</span> <span class="string">"北京市"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">"street":</span> <span class="string">"北京市西土城路10号"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">"zipcode":</span> <span class="string">"100876"</span></span><br></pre></td></tr></table></figure><h2 id="信息提取的一般方法"><a href="#信息提取的一般方法" class="headerlink" title="信息提取的一般方法"></a>信息提取的一般方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>使用标记解析器完整解析信息的标记形式，再提取关键信息。</p><p>优点：</p><blockquote><p>信息解析准确</p></blockquote><p>缺点：</p><blockquote><p>提取过程繁琐，速度慢</p></blockquote><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>无视标记形式，使用文本查找函数直接搜索关键信息。</p><p>优点：</p><blockquote><p>提取过程简洁，速度较快</p></blockquote><p>缺点：</p><blockquote><p>提取结果准确性和信息内容直接相关</p></blockquote><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>使用标记解析器解析信息，再使用文本查找函数直接搜索关键信息。</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提取HTML中所有的url链接</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">"http://python123.io/ws/demo.html"</span>)</span><br><span class="line">r.text</span><br><span class="line">demo = r.text</span><br><span class="line">soup = BeautifulSoup(demo, <span class="string">"html.parser"</span>)</span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>):</span><br><span class="line">    print(link.get(<span class="string">'href'</span>))</span><br></pre></td></tr></table></figure><h2 id="基于bs4的HTML内容查找方法"><a href="#基于bs4的HTML内容查找方法" class="headerlink" title="基于bs4的HTML内容查找方法"></a>基于bs4的HTML内容查找方法</h2><p><a href="https://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener" title="Beautiful Soup简介">Beautiful Soup</a>中提供了一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;.find_all(name,attrs,recursive,string,**kwargs)</span><br></pre></td></tr></table></figure><p>它返回一个列表类型，存储查找的结果。</p><ul><li>name：对标签名称的检索字符串<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">"http://python123.io/ws/demo.html"</span>)</span><br><span class="line">demo = r.text</span><br><span class="line">soup= BeautifulSoup(demo,<span class="string">"html.parser"</span>)</span><br><span class="line">soup.find_all(<span class="string">'a'</span>) <span class="comment">#输出一个列表类型，其中包含了所有出现的a标签</span></span><br><span class="line">soup.find_all([<span class="string">'a'</span>,<span class="string">'b'</span>]) <span class="comment">#这时候a标签和b标签会作为一个列表形式打印</span></span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="literal">True</span>): <span class="comment">#如果参数为True，则会包含所有的标签</span></span><br><span class="line">    print(tag.name)</span><br></pre></td></tr></table></figure>如果我们希望只显示以b开头的标签：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里我们需要使用正则表达式</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(re.compile(<span class="string">'b'</span>)): <span class="comment">#正则表达式返回的是以b开头的所有的信息</span></span><br><span class="line">    print(tag.name)</span><br></pre></td></tr></table></figure></li><li>attrs：对标签属性值的检索字符串，可标注属性检索<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">'p'</span>,<span class="string">'course'</span>) <span class="comment">#p标签中包含course的信息</span></span><br><span class="line">soup.find_all(id=<span class="string">'link1'</span>) <span class="comment">#也可以直接对属性进行约定</span></span><br><span class="line">soup.find_all(id=<span class="string">'link'</span>) <span class="comment">#如果不包含所约定的标签返回列表</span></span><br><span class="line">soup.find_all(id=re.compile(<span class="string">'link'</span>)) <span class="comment">#这时我们可以利用正则表达式</span></span><br></pre></td></tr></table></figure></li><li>recursive：是否对标签树中所有子孙节点全部检索，默认为True<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">'a'</span>, recursive=<span class="literal">False</span>) <span class="comment">#这时候返回空列表，说明儿子节点中没有a标签</span></span><br></pre></td></tr></table></figure></li><li>string 对字符串区域检索字符串的参数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(string=<span class="string">"Advanced Python"</span>) <span class="comment">#必须精确的输入字符串区域的字符串才能检索</span></span><br><span class="line">soup.find_all(string=re.compile(<span class="string">"Python"</span>))<span class="comment">#如果你想检索带有Python的字符串则同样可以利用正则表达式</span></span><br></pre></td></tr></table></figure></li></ul><p>由于这个方法经常使用，我们可以世界使用soup()来代替soup.find_all()。</p><h3 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h3><ul><li>.find() 搜索且只返回一个结果，字符串类型</li><li>.find_parents() 在先辈节点中搜索，返回列表类型</li><li>.find_parent() 在先辈节点中返回一个结果，返回列表类型</li><li>.find_next_siblings() 在后续平行节点中搜索，字符串类型</li><li>.find_next_sibling() 在后续平行节点中返回一个结果，返回列表类型</li><li>.find_previous_siblings() 在前序平行节点中搜索，字符串类型</li><li>.find_previous_sibling() 在前序平行节点中返回一个结果，返回列表类型</li></ul><p>它们的参数都和.find_all()的参数一样，区别仅在于检索区域和返回内容的不同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（五）——Beautiful Soup库</title>
      <link href="/2020/02/02/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94Beautiful-Soup%E5%BA%93/"/>
      <url>/2020/02/02/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94Beautiful-Soup%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫（五）——Beautiful-Soup库"><a href="#Python爬虫（五）——Beautiful-Soup库" class="headerlink" title="Python爬虫（五）——Beautiful Soup库"></a>Python爬虫（五）——<a href="https://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener" title="Beautiful Soup简介">Beautiful Soup</a>库</h1><a id="more"></a><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ul><li><ol><li>打开命令提示符</li></ol></li><li><ol start="2"><li>输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试界面：</p><blockquote><p><a href="http://python123.io/ws/demo.html" target="_blank" rel="noopener">http://python123.io/ws/demo.html</a></p></blockquote><ul><li>首先查看网页源代码（打开页面CTRL+U）</li><li>然后打开IDLE，输入以下代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">"http://python123.io/ws/demo.html"</span>)</span><br><span class="line">r.text</span><br><span class="line">demo = r.text</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="comment">#Beautiful Soup库的缩写为bs4</span></span><br><span class="line">soup = BeautifulSoup(demo , <span class="string">"html.parser"</span>)<span class="comment">#这里需要一个解释器使用的是html的解释器</span></span><br><span class="line">print(soup.prettify()) <span class="comment">#如果出现之前看到的网页源代码即为安装成功</span></span><br></pre></td></tr></table></figure></li></ul><p>使用方法总结：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(<span class="string">'&lt;p&gt;data&lt;/p&gt;'</span>,<span class="string">'html.parser'</span>) <span class="comment">#第一个参数是我们需要解析的HTML代码</span></span><br><span class="line">soup2 = BeautifulSoup(open(<span class="string">"D://demo.html"</span>),<span class="string">'html.parser'</span>)</span><br></pre></td></tr></table></figure><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>Beautiful Soup库是解析、遍历、维护“标签树”的功能库。</p><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><ul><li>bs4的HTML解析器:html.parser 需要安装bs4库</li><li>lxml的HTML解析器:lxml 需要安装lxml<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure></li><li>lxml的HTML解析器:xml 需要安装lxml</li><li>html5lib的解析器:html5lib 需要安装html5lib<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install html5lib</span><br></pre></td></tr></table></figure></li></ul><h2 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h2><ul><li>Tag 标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;标明开头和结尾。用.<tag>的方式获得</tag></li><li>Name 标签的名字，格式：<tag>.name</tag></li><li>Attributes 标签的属性，字典形式组织，格式：<tag>.attrs</tag></li><li>NavigableString 标签内非属性字符，格式：<tag>.string</tag></li><li>Comment 标签内字符串的注释部分，一种特殊的Comment类型</li></ul><p>可以用前面的demo来展示，在IDLE中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soup.title</span><br><span class="line">soup.a</span><br><span class="line">tag = soup.a</span><br><span class="line">tag.name</span><br><span class="line">tag.attrs</span><br><span class="line">tag.string</span><br></pre></td></tr></table></figure><h2 id="基于bs4库的HTML内容遍历方法"><a href="#基于bs4库的HTML内容遍历方法" class="headerlink" title="基于bs4库的HTML内容遍历方法"></a>基于bs4库的HTML内容遍历方法</h2><p>这里使用前面的demo。</p><h3 id="下行遍历"><a href="#下行遍历" class="headerlink" title="下行遍历"></a>下行遍历</h3><p>从标签树由根节点到叶子节点。</p><h4 id="三个属性"><a href="#三个属性" class="headerlink" title="三个属性"></a>三个属性</h4><ul><li>.contents 子节点的列表，将<tag>所有儿子节点存入列表</tag></li><li>.children 子节点的迭代类型，与.contents类似，用于循环遍历儿子节点</li><li>.descendants 子孙节点的迭代类型，包含所有子孙节点，用于循环遍历</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>使用前面的demo演示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">soup.head</span><br><span class="line">soup.head.contents</span><br><span class="line">soup.body.contents</span><br><span class="line">len(soup.body.contents)</span><br><span class="line">soup.body.contents[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> soup.body.children:</span><br><span class="line">    print(child) <span class="comment">#遍历儿子节点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> soup.body.contents:</span><br><span class="line">    print(child) <span class="comment">#遍历子孙节点</span></span><br></pre></td></tr></table></figure><h3 id="上行遍历"><a href="#上行遍历" class="headerlink" title="上行遍历"></a>上行遍历</h3><p>从标签树由叶子节点到根节点。</p><h4 id="两个属性"><a href="#两个属性" class="headerlink" title="两个属性"></a>两个属性</h4><ul><li>.parent 节点的父亲标签</li><li>.parents 节点的先辈标签的迭代类型，用于循环遍历先辈节点</li></ul><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soup.title.parent</span><br><span class="line">soup.html.parent <span class="comment">#html是文本最高标签，所以是自己</span></span><br><span class="line"><span class="keyword">for</span> parent <span class="keyword">in</span> soup.a.parents:</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#如果先辈是None，就不再打印</span></span><br><span class="line">        print(parent)</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        print(parent.name)</span><br></pre></td></tr></table></figure><h3 id="平行遍历"><a href="#平行遍历" class="headerlink" title="平行遍历"></a>平行遍历</h3><p>在同一个父节点下的平级节点之间平行遍历，但是要注意到平行标签的下一个有可能为navigableString类型。</p><h4 id="四个属性"><a href="#四个属性" class="headerlink" title="四个属性"></a>四个属性</h4><ul><li>next_sibling 返回按照HTML文本顺序的下一个平行节点的标签</li><li>previous_sibling 返回按照HTML文本顺序的上一个平行节点标签</li><li>next_siblings 迭代类型，返回按照HTML文本顺序的后续所有平行节点标签</li><li>previous_siblings 迭代类型，返回按照HTML文本顺序的前续所有平行节点标签</li></ul><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soup.a.next_sibling</span><br><span class="line">soup.a.next_sibling.next_sibling</span><br><span class="line">soup.a.previous_sibling</span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> soup.a.next_siblings:</span><br><span class="line">    print(sibling) <span class="comment">#遍历后续节点</span></span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> soup.a.previous_siblings:</span><br><span class="line">    print(sibling) <span class="comment">#遍历前续节点</span></span><br></pre></td></tr></table></figure><h2 id="基于bs4库的HTML格式输出"><a href="#基于bs4库的HTML格式输出" class="headerlink" title="基于bs4库的HTML格式输出"></a>基于bs4库的HTML格式输出</h2><p>为了方便程序的读取，这里可以使用prettify方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用前面的demo</span></span><br><span class="line">print(soup.prettify())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（四）——五个基础爬虫实例</title>
      <link href="/2020/02/01/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E4%BA%94%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/"/>
      <url>/2020/02/01/Python%E7%88%AC%E8%99%AB%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E4%BA%94%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫（四）——五个基础爬虫实例"><a href="#Python爬虫（四）——五个基础爬虫实例" class="headerlink" title="Python爬虫（四）——五个基础爬虫实例"></a>Python爬虫（四）——五个基础爬虫实例</h1><a id="more"></a><h2 id="爬取京东商城商品"><a href="#爬取京东商城商品" class="headerlink" title="爬取京东商城商品"></a>爬取京东商城商品</h2><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://item.jd.com/100009996740.html"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    r.raise_for_status() <span class="comment">#不返回200产生异常</span></span><br><span class="line">    r.encoding = r.aparent_encoding</span><br><span class="line">    print(r.text[:<span class="number">1000</span>])<span class="comment">#如果r.text过多会在IDLE上无法显示</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure><h2 id="爬取亚马逊商品界面"><a href="#爬取亚马逊商品界面" class="headerlink" title="爬取亚马逊商品界面"></a>爬取亚马逊商品界面</h2><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://www.amazon.cn/b/ref=s9_acss_bw_cg_WKebook_1a1_w?node=116169071&amp;pf_rd_m=A1U5RCOVU0NYF2&amp;pf_rd_s=merchandised-search-9&amp;pf_rd_r=SGMKFB10R7MV2VEZXX20&amp;pf_rd_t=101&amp;pf_rd_p=d857603c-3657-40b3-a25b-d5fe03fd4e10&amp;pf_rd_i=116087071"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">'user-agent'</span>:<span class="string">'chrome:10.0'</span>&#125;<span class="comment">#与访问京东商城不同，我们需要更改headers字段模拟浏览器访问亚马逊商城。</span></span><br><span class="line">    r = requests.get(url,header=kv)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.aparent_encoding</span><br><span class="line">    print(r.text[<span class="number">1000</span>:<span class="number">2000</span>])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure><h2 id="百度-360搜索关键词提交"><a href="#百度-360搜索关键词提交" class="headerlink" title="百度/360搜索关键词提交"></a>百度/360搜索关键词提交</h2><p>百度和360都提供了关键词提交接口：</p><blockquote><p>百度：<a href="http://www.baidu.com/s?wd=keyword" target="_blank" rel="noopener">http://www.baidu.com/s?wd=keyword</a></p></blockquote><blockquote><p>360：<a href="http://www.so.com/s?q=keyword" target="_blank" rel="noopener">http://www.so.com/s?q=keyword</a></p></blockquote><p>所以我们只用替换关键词就可以了。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">keword = <span class="string">"Python爬虫"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv =  &#123;<span class="string">'wd'</span>:keyword&#125;</span><br><span class="line">    user = &#123;<span class="string">'user-agent'</span>:<span class="string">'chrome/10.0'</span>&#125;</span><br><span class="line">    r = requests.get(<span class="string">'https://www.baidu.com/s'</span>,headers=user,params=kv)</span><br><span class="line">    print(r.request.url)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    print(len(r.text))<span class="comment">#之后再加入爬取数据处理</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure><h2 id="网络图片的爬取和存储"><a href="#网络图片的爬取和存储" class="headerlink" title="网络图片的爬取和存储"></a>网络图片的爬取和存储</h2><p>我们需要得到网络图片的地址（找到图片右键复制图片地址）。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">url = <span class="string">"http://image.ngchina.com.cn/userpic/107269/2019/11181936061072693671.jpeg"</span><span class="comment">#得到的图片地址</span></span><br><span class="line">path = <span class="string">"D:/getImage.jpg"</span><span class="comment">#你想保存的文件路径</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line">        f.close()</span><br><span class="line">        print(<span class="string">"文件保存成功"</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure><h2 id="IP地址归属地的自动查询"><a href="#IP地址归属地的自动查询" class="headerlink" title="IP地址归属地的自动查询"></a>IP地址归属地的自动查询</h2><p>在IP138我们可以查询IP地址归属地。我们可以用它的url接口：</p><blockquote><p><a href="http://m.ip138.com/ip.asp?ip=ipaddress" target="_blank" rel="noopener">http://m.ip138.com/ip.asp?ip=ipaddress</a></p></blockquote><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"https://m.ip138.com/ip.asp?ip="</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url+<span class="string">'124.127.207.15'</span>)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding = r.aparent_encoding</span><br><span class="line">    r.text[<span class="number">-500</span>:]</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（三）——Robots协议</title>
      <link href="/2020/02/01/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Robots%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/02/01/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Robots%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫（三）——Robots协议"><a href="#Python爬虫（三）——Robots协议" class="headerlink" title="Python爬虫（三）——Robots协议"></a>Python爬虫（三）——Robots协议</h1><p>Robots协议全称为Robots Exclusion Standard，网络爬虫排除标准。它的作用是告知网络爬虫哪些可以抓取哪些不可以。通常被放在网站根目录下的robots.txt。</p><p>注：并不是所有网站都有Robots协议，如果没有默认为内容都可以爬取。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#*代表所有，&#x2F;代表根目录</span><br><span class="line">User-agent:*</span><br><span class="line">Disallow:&#x2F;</span><br></pre></td></tr></table></figure><ul><li>User-agent 限制的User-agent</li><li>Disallow 不允许访问的目录<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>自动或人工识别robots.tst，再进行内容爬取。</li></ul><p>你也可以不遵守robots.txt，但会产生风险。只有当你的程序不会对服务器产生威胁或者行为类似人类的时候可以不遵守robots.txt。这时候你获取的资源不能用于商业用途。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（二）——requests库</title>
      <link href="/2020/01/30/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94requests%E5%BA%93/"/>
      <url>/2020/01/30/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94requests%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a><a href="https://requests.readthedocs.io/en/master/" target="_blank" rel="noopener" title="requests库的信息">requests库</a></h1><p>公认的爬取网页最好的库</p><a id="more"></a><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>用cmd打开控制台，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>抓取百度的网页代码。</p><p>打开IDLE输入一下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">r.status_code</span><br><span class="line">r.encoding = <span class="string">"UTF-8"</span></span><br><span class="line">r.text</span><br></pre></td></tr></table></figure><p>状态码为200即为成功，否则失败。</p><p><img src="/2020/01/30/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94requests%E5%BA%93/requests%E5%BA%93test.jpg" alt="爬取百度结果" title="爬取百度结果"></p><h2 id="7个主要方法"><a href="#7个主要方法" class="headerlink" title="7个主要方法"></a>7个主要方法</h2><h3 id="requests-requests"><a href="#requests-requests" class="headerlink" title="requests.requests()"></a>requests.requests()</h3><p>构造一个请求，支撑所有方法的基础。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.requests(method,url,**kewargs)</span><br></pre></td></tr></table></figure><ul><li>method：请求方式，对应get/put/post等七种</li><li>url：获取页面的url链接</li><li>**kwargs：13个控制访问参数。其中params的使用方法：<br><img src="/2020/01/30/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94requests%E5%BA%93/requests-kewargs.jpg" alt="kwargs使用方法" title="kwargs使用方法"></li></ul><h4 id="kwargs的13个参数"><a href="#kwargs的13个参数" class="headerlink" title="**kwargs的13个参数"></a>**kwargs的13个参数</h4><ul><li><strong>params</strong>：字典或字节序列，作为参数增加到url中</li><li><strong>data</strong>：字典、字节序列或文件对象，作为Request的内容</li><li><strong>json</strong>：JSON格式的数据，作为Request的内容</li><li><strong>headers</strong>：字典，HTTP定制头</li><li>cookies：字典或CookieJar，Request中的cookie</li><li>auth：元组，支持HTTP认证功能</li><li>files：字典类型，传输文件</li><li>timeout：设定超时时间，单位为秒</li><li>proxies：字典类型，设定访问代理服务器，可以增加登录认证</li><li>allow_redirects:True/False，默认为True，重定向开关</li><li>stream：True/False，默认为True，获取内容立即下载开关</li><li>verify：True/False，默认为True，认证SSL证书开关</li><li>cert：本地SSL证书路径</li></ul><h3 id="requests-get"><a href="#requests-get" class="headerlink" title="requests.get()"></a>requests.get()</h3><p>获取HTML网页的主要方法，对应于与HTTP的GET方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r= requests.get(url)</span><br></pre></td></tr></table></figure><p>构造一个向服务器请求资源的Request对象，返回一个包含服务器资源的Response对象。</p><p>完整的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(url,params = <span class="literal">None</span>,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>url：拟获取页面的url链接</li><li>params：url中的额外参数，字典或字节流格式，可选</li><li>**kwargs：12个控制访问的参数，可选。requests中除了params的参数</li></ul><p>get方法实际上使用了requests方法来封装。</p><h4 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h4><h5 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h5><ul><li>r.status_code HTTP请求的返回状态，200表示连接成功，404表示失败。</li><li>r.text HTTP响应内容的字符串形式。即url对应的页面内容。</li><li>r.encoding 从HTTP hear中<strong>猜测</strong>的响应内容编码方式。如果在返回的header中charset为空默认为ISO-8859-1。</li><li>r.apparent_encoding 从内容中<strong>分析</strong>出的响应内容编码方式（备选编码方式）。</li><li>r.content HTTP响应内容的二进制形式。</li></ul><h3 id="requests-head"><a href="#requests-head" class="headerlink" title="requests.head()"></a>requests.head()</h3><p>获取HTML网页头信息的方法，对应于HTTP的HEAD方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.head(url,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>url：获取页面的url链接</li><li>**kwargs：13个控制访问的参数</li></ul><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = requests.head(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">r.headers</span><br><span class="line">r.text</span><br></pre></td></tr></table></figure><h3 id="requests-post"><a href="#requests-post" class="headerlink" title="requests.post()"></a>requests.post()</h3><p>向HTML网页提交POST请求的方法，对应于HTTP的POST。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.post(url,data=<span class="literal">None</span>,json=<span class="literal">None</span>,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>url：更新页面的url链接</li><li>data：字典、字节序列或文件，Request的内容</li><li>json：JSON格式的数据，Request的内容</li><li>**kwargs：11个控制访问的参数（除了requests中的data和json）</li></ul><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload  = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, data = payload)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2020/01/30/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94requests%E5%BA%93/post.jpg" alt="post请求结果" title="post请求结果"></p><h3 id="requests-put"><a href="#requests-put" class="headerlink" title="requests.put()"></a>requests.put()</h3><p>向HTML网页提交PUT请求的方法，对应于HTTP的PUT。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.put(url,data= <span class="literal">None</span>,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>url：更新页面的url链接</li><li>data：字典、字节序列或文件，Request的内容</li><li>**kwargs：12个控制访问的参数（除了requests中的data）</li></ul><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload  = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.put(<span class="string">'http://httpbin.org/put'</span>, data = payload)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2020/01/30/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94requests%E5%BA%93/put.jpg" alt="put请求结果" title="put请求结果"></p><h3 id="requests-patch"><a href="#requests-patch" class="headerlink" title="requests.patch()"></a>requests.patch()</h3><p>向HTML网页提交局部修改请求的方法，对应于HTTP的PATCH。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.patch(url,data= <span class="literal">None</span>,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>url：更新页面的url链接</li><li>data：字典、字节序列或文件，Request的内容</li><li>**kwargs：12个控制访问的参数（除了requests中的data）</li></ul><h3 id="requests-delete"><a href="#requests-delete" class="headerlink" title="requests.delete()"></a>requests.delete()</h3><p>向HTML页面提交删除请求的方法，对应于HTTP的DELETE。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.delete(url,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>url：更新页面的url链接</li><li>**kwargs：13个控制访问的参数</li></ul><h2 id="通用代码框架"><a href="#通用代码框架" class="headerlink" title="通用代码框架"></a>通用代码框架</h2><h3 id="六种常见的异常"><a href="#六种常见的异常" class="headerlink" title="六种常见的异常"></a>六种常见的异常</h3><ul><li>requests.ConnectionError 网络连接错误异常，如DNS查询失败、拒绝连接等。</li><li>requests.HTTPError HTTP错误异常</li><li>requests.URLRequired URL缺失异常</li><li>requests.TooManyRedirects 超过最大重定向次数，产生重定向异常</li><li>requests.ConnectTimeout 连接远程服务器超时异常</li><li>requests.Timeout 请求URL超时，产生超市异常</li></ul><h3 id="r-raise-fo-status"><a href="#r-raise-fo-status" class="headerlink" title="r.raise_fo_status()"></a>r.raise_fo_status()</h3><p>如果返回值不是200，产生异常requests.HTTPError</p><h3 id="通用代码框架-1"><a href="#通用代码框架-1" class="headerlink" title="通用代码框架"></a>通用代码框架</h3><p>爬取页面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status() <span class="comment">#如果状态不是200，引发HTTPError异常</span></span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> t.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br></pre></td></tr></table></figure><p>最大的用处是使用户爬取网页变得更有效、更稳定、更可靠。</p><h2 id="HTTP协议及Requests库方法"><a href="#HTTP协议及Requests库方法" class="headerlink" title="HTTP协议及Requests库方法"></a>HTTP协议及Requests库方法</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>Hypertext Transfer Protocol，超文本传输协议。是一个基于“请求与响应”模式、无状态的应用层协议。采用URL作为定位网络资源的格式（http:// host [:port] [path],host:合法的Internet主机或IP地址,port:端口号,path:请求资源的路径）。URL使通过HTTP协议存取资源的Internet路径。一个URL对应一个数据资源。</p><h4 id="HTTP协议对资源的操作"><a href="#HTTP协议对资源的操作" class="headerlink" title="HTTP协议对资源的操作"></a>HTTP协议对资源的操作</h4><ul><li>GET 请求获取URL位置的资源。</li><li>HEAD 请求获取URL位置资源的响应消息报告，即获得该资源的头部信息。</li><li>POST 请求向URL位置的资源后附加新的数据。</li><li>PUT 请求向URL位置存储一个资源，<strong>覆盖</strong>原URL位置的资源。</li><li>PATCH 请求<strong>局部更新</strong>URL位置的资源，即改变该处资源的部分内容。</li><li>DELETE 请求i删除URL位置存储的资源。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于网络安全的限制，我们最常使用的是requests.get()方法，某些时候会使用requests.head()方法。</p><p>由于网络链接的问题我们需要一个通用代码框架。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫（一）——开发环境</title>
      <link href="/2020/01/30/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/01/30/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="python爬虫（一）——开发环境"><a href="#python爬虫（一）——开发环境" class="headerlink" title="python爬虫（一）——开发环境"></a>python爬虫（一）——开发环境</h1><h2 id="IDLE"><a href="#IDLE" class="headerlink" title="IDLE"></a>IDLE</h2><p><a href="https://baike.baidu.com/item/IDLE" target="_blank" rel="noopener" title="about IDLE">IDLE</a>是Python的集成开发环境，被打包为Python包装的可选部分。它是一个入门级的代码编写工具，适合编写较短的程序。</p><h2 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h2><p><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener" title="Sublime Text download">Sublime Text</a>是一个专门为程序员开发的文本编辑器。它是一个收费软件，但是可以无限期的试用。Sublime Text 支持多种编程语言的语法高亮、拥有优秀的代码自动完成功能，还拥有代码片段（Snippet）的功能，可以将常用的代码片段保存起来，在需要时随时调用。支持 VIM 模式，可以使用Vim模式下的多数命令。</p><h2 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h2><p><a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener" title="PyCharm download">PyCharm</a>是一个由JetBrains打造的Python IDE。它的社区版免费，使用简单，集成度高。适合于较复杂的工程。</p><h2 id="Anaconda-amp-Spyder"><a href="#Anaconda-amp-Spyder" class="headerlink" title="Anaconda &amp; Spyder"></a>Anaconda &amp; Spyder</h2><p><a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener" title="Anaconda download">Anaconda</a>是一个开源的Python发行版本，包含了conda、Python的180多个科学包及其依赖项。它适合用于科学计算。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019摄影记录</title>
      <link href="/2020/01/09/2019%E6%91%84%E5%BD%B1%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/01/09/2019%E6%91%84%E5%BD%B1%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="2019摄影记录"><a href="#2019摄影记录" class="headerlink" title="2019摄影记录"></a>2019摄影记录</h1><a id="more"></a><p>在2019年10月4日，我拥有了人生里的第一台相机。在过去的几个月里，我带着它去了后海，去了古北水镇，还去了陶然亭。我也用它记录了我的学校，同学们的表演还有室友的生日。由于学校里事务繁多，没有能够抽出时间系统的学习摄影和后期，所以拍得一般。不过好歹也是自己拍出来的，敝帚自珍嘛。于是乎，我在这里列出几张自己比较喜欢的照片，也希望大家能够喜欢。</p><p><img src="/2020/01/09/2019%E6%91%84%E5%BD%B1%E8%AE%B0%E5%BD%95/%E5%90%8E%E6%B5%B7-%E6%9C%88%E4%BA%AE.jpg" alt="后海-月亮" title="后海-月亮"></p><p><img src="/2020/01/09/2019%E6%91%84%E5%BD%B1%E8%AE%B0%E5%BD%95/%E5%90%8E%E6%B5%B7-%E8%A1%97%E9%81%93.jpg" alt="后海-街道" title="后海-街道"></p><p><img src="/2020/01/09/2019%E6%91%84%E5%BD%B1%E8%AE%B0%E5%BD%95/%E6%9C%AC%E9%83%A8-%E9%93%B6%E6%9D%8F.jpg" alt="本部-银杏" title="本部-银杏"></p><p><img src="/2020/01/09/2019%E6%91%84%E5%BD%B1%E8%AE%B0%E5%BD%95/%E9%99%B6%E7%84%B6%E4%BA%AD-%E5%B0%8F%E6%8F%90%E7%90%B4.jpg" alt="陶然亭-小提琴" title="陶然亭-小提琴"></p><p><img src="/2020/01/09/2019%E6%91%84%E5%BD%B1%E8%AE%B0%E5%BD%95/%E9%99%B6%E7%84%B6%E4%BA%AD-%E9%A3%9E%E9%B8%9F.jpg" alt="陶然亭-飞鸟" title="陶然亭-飞鸟"></p><p><img src="/2020/01/09/2019%E6%91%84%E5%BD%B1%E8%AE%B0%E5%BD%95/%E5%8F%A4%E5%8C%97%E6%B0%B4%E9%95%87-%E6%B0%B4%E9%81%93.jpg" alt="古北水镇-水道" title="古北水镇-水道"></p><p><img src="/2020/01/09/2019%E6%91%84%E5%BD%B1%E8%AE%B0%E5%BD%95/%E5%8F%A4%E5%8C%97%E6%B0%B4%E9%95%87-%E6%B0%B4%E5%BA%93.jpg" alt="古北水镇-水库" title="古北水镇-水库"></p><p><img src="/2020/01/09/2019%E6%91%84%E5%BD%B1%E8%AE%B0%E5%BD%95/%E6%B2%99%E6%B2%B3-%E8%90%BD%E6%97%A5.jpg" alt="沙河-落日" title="沙河-落日"></p><p><img src="/2020/01/09/2019%E6%91%84%E5%BD%B1%E8%AE%B0%E5%BD%95/%E7%94%9F%E6%97%A5-%E8%A1%97%E9%81%93.jpg" alt="生日-街道" title="生日-街道"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS 进程</title>
      <link href="/2020/01/08/os%E8%BF%9B%E7%A8%8B/"/>
      <url>/2020/01/08/os%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>在CPU中的活动称为进程。</p><a id="more"></a><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p>进程组成：</p><blockquote><ul><li>文本段（或代码段）</li><li>当前活动（通过程序计数器的值和处理器寄存器的内容来表示）</li><li>堆栈段（临时数据，如函数参数、返回地址、局部变量）</li><li>数据段（全局变量）</li><li>堆（heap）</li></ul></blockquote><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>新的：进程正在被创建</li><li>运行：指令正在被执行</li><li>等待：进程等待某个事件发生</li><li>就绪：进程等待分配处理器</li><li>终止：进行完成执行</li></ul><p><img src="/2020/01/08/os%E8%BF%9B%E7%A8%8B/os%E7%AC%AC%E4%B8%89%E7%AB%A01.jpg" alt="进程状态图" title="进程状态图"></p><h3 id="进程控制块（process-control-block，PCB）"><a href="#进程控制块（process-control-block，PCB）" class="headerlink" title="进程控制块（process control block，PCB）"></a>进程控制块（process control block，PCB）</h3><p>1.进程状态<br>2.程序计数器</p><blockquote><p>计数器表示进程要执行的下个指令的地址</p></blockquote><p>3.CPU寄存器</p><blockquote><p>累加器、索引寄存器、堆栈指针和通用寄存器等</p></blockquote><p>4.CPU调度信息</p><blockquote><p>进程优先级、调度队列的指针和其他调度参数。</p></blockquote><p>5.内存管理信息</p><blockquote><p>基址寄存器和界限寄存器的值、页表或段表</p></blockquote><p>6.记账信息</p><blockquote><p>CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量</p></blockquote><p>7.I/O状态信息</p><blockquote><p>分配给进程的I/O设备列表、打开的文件列表等</p></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h3><p>1.作业队列</p><blockquote><p>该队列包括系统中的所有进程</p></blockquote><p>2.就绪队列（通常用链表实现）</p><blockquote><p>内存中就绪的、等待的进程</p></blockquote><p>3.设备队列</p><blockquote><p>等待特定I/O设备的进程</p></blockquote><h3 id="调度程序-scheduler"><a href="#调度程序-scheduler" class="headerlink" title="调度程序(scheduler)"></a>调度程序(scheduler)</h3><h4 id="长期调度程序（long-term-scheduler，或作业调度程序（job-scheduler））"><a href="#长期调度程序（long-term-scheduler，或作业调度程序（job-scheduler））" class="headerlink" title="长期调度程序（long-term scheduler，或作业调度程序（job scheduler））"></a>长期调度程序（long-term scheduler，或作业调度程序（job scheduler））</h4><blockquote><p>一些批处理系统，进程更多的是被提交，所以都被放在大容量存储设备中。长期调度程序从大容量的存储设备中选择程序，放到内存中准备执行。</p></blockquote><h4 id="短期调度程序（short-term-scheduler，或CPU调度程序）"><a href="#短期调度程序（short-term-scheduler，或CPU调度程序）" class="headerlink" title="短期调度程序（short-term scheduler，或CPU调度程序）"></a>短期调度程序（short-term scheduler，或CPU调度程序）</h4><blockquote><p>短期调度程序是从准备执行的进程中选择进程，然后为之分配CPU。</p></blockquote><h4 id="程序可以分为I-O为主和CPU为主"><a href="#程序可以分为I-O为主和CPU为主" class="headerlink" title="程序可以分为I/O为主和CPU为主"></a>程序可以分为I/O为主和CPU为主</h4><p><strong>I/O为主（I/O-bound progress）</strong>：</p><blockquote><p>执行I/O方面的时间更多</p></blockquote><p><strong>CPU为主（CPU-bound progress）</strong>：</p><blockquote><p>很少产生I/O请求</p></blockquote><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>中断时，系统需要保存当前运行在CPU上的进程的上下文，从而在其处理完后能够恢复上下文。通常，通过执行一个<strong>状态保存（state save）</strong>来保存CPU当前状态，之后执行一个<strong>状态恢复（state restore）</strong>重新开始。<br>这个将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态称为<strong>上下文切换（context switch）</strong>。</p><h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>进程（父进程）在执行过程中，能够通过创建程序系统调用创建多个新进程（子进程）。创建进程需要一定的资源（如：CPU时间、内存、文件、I/O设备），子进程可能从系统获得资源，也可能直接从父进程中获得资源。<br>当进程创建新进程时有两种执行可能：</p><blockquote><p>1.父进程与子进程并发执行<br>2.父进程等待，知道某个或全部子进程执行完</p></blockquote><p>新进程的地址空间也有两种可能：</p><blockquote><p>1.子进程时父进程的复制品<br>2.子程序装入另一个新程序</p></blockquote><p><img src="/2020/01/08/os%E8%BF%9B%E7%A8%8B/os%E7%AC%AC%E4%B8%89%E7%AB%A02.jpg" alt="进程生成" title="进程生成"></p><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>当进程完成执行最后的语句并使用系统调用exit()请求系统删除自身时，进程终止。<br>父进程终止子进程的原因：</p><blockquote><ul><li>子进程使用了超过它所分配的资源</li><li>分配给子进程的任务不再需要</li><li>父进程退出（级联终止（cascading termination））</li></ul></blockquote><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>需要提供环境以允许进程协作的理由:</p><blockquote><ul><li>信息共享（information sharing）</li><li>提高运算速度（computation speedup）</li><li>模块化（modularity）</li><li>方便（convenience）</li></ul></blockquote><p>进程间通信机制（interprocess communication，IPC）：用来允许进程相互交换数据与信息。两种基本模式：</p><blockquote><p>1.共享内存<br>2.消息传递</p></blockquote><p><img src="/2020/01/08/os%E8%BF%9B%E7%A8%8B/os%E7%AC%AC%E4%B8%89%E7%AB%A03.jpg" alt="通信模型" title="通信模型"></p><h3 id="共享内存系统"><a href="#共享内存系统" class="headerlink" title="共享内存系统"></a>共享内存系统</h3><p>采用共享内存的进程间通信需要建立共享内存区域。</p><h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><p>生产者进程产生信息以供消费者进程消费，这就必须要求建立缓冲来满足生产者和消费者的消费。<strong>无限缓冲（unbounded-buffer）</strong>，对缓冲大小没有限制。<strong>有限缓冲（bounded-buffer）</strong>，缓冲大小固定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;item;</span><br><span class="line"></span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> out = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/08/os%E8%BF%9B%E7%A8%8B/os%E7%AC%AC%E4%B8%89%E7%AB%A04.jpg" alt="代码实例" title="生产者消费者问题"></p><h3 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h3><p>需求：</p><blockquote><p>发送和接受<br>通信线路（communication link）</p><blockquote><ul><li>直接或间接通信</li><li>同步或异步通信</li><li>自动或显示缓冲</li></ul></blockquote></blockquote><h4 id="1-命名"><a href="#1-命名" class="headerlink" title="1.命名"></a>1.命名</h4><p>直接通信：需要通信的每个进程必须明确地命名通信的接收者和发送者。<br>间接通信：通过邮箱或端口来发送和接受消息。</p><h4 id="2-同步（阻塞或非阻塞——同步或异步）"><a href="#2-同步（阻塞或非阻塞——同步或异步）" class="headerlink" title="2.同步（阻塞或非阻塞——同步或异步）"></a>2.同步（阻塞或非阻塞——同步或异步）</h4><blockquote><ul><li>阻塞 send：发送进程阻塞，直到消息被接受进程或邮箱所接受</li><li>非阻塞 send：发送进程发送消息并继续操作</li><li>阻塞 receive：接收者阻塞，直到有消息可用</li><li>非阻塞 receive：接收者收到一个有效消息或空消息</li></ul></blockquote><p>都阻塞的时候，发送者和接收者之间就有一个集合点（rendzvous）。</p><h4 id="3-缓冲"><a href="#3-缓冲" class="headerlink" title="3.缓冲"></a>3.缓冲</h4><blockquote><ul><li>零容量：队列的最大长度为0。这种情况必须阻塞发送。</li><li>有限容量</li><li>无限容量</li></ul></blockquote><h2 id="客户机-服务器系统通信"><a href="#客户机-服务器系统通信" class="headerlink" title="客户机-服务器系统通信"></a>客户机-服务器系统通信</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>套接字（Socket）可定义为通信的端点。一对通过网络通信的进程需要使用一对Socket。</p><p><img src="/2020/01/08/os%E8%BF%9B%E7%A8%8B/os%E7%AC%AC%E4%B8%89%E7%AB%A05.jpg" alt="使用Socket通信" title="使用Socket通信"></p><h3 id="远程过程调用"><a href="#远程过程调用" class="headerlink" title="远程过程调用"></a>远程过程调用</h3><p>最为普通的远程服务——RPC方式</p><p><img src="/2020/01/08/os%E8%BF%9B%E7%A8%8B/os%E7%AC%AC%E4%B8%89%E7%AB%A06.jpg" alt="远程过程调用（RPC）" title="远程过程调用（RPC）"></p><h3 id="远程方法调用（remote-method-invocation）"><a href="#远程方法调用（remote-method-invocation）" class="headerlink" title="远程方法调用（remote method invocation）"></a>远程方法调用（remote method invocation）</h3><p>类似于RPC的Java特性</p><p><img src="/2020/01/08/os%E8%BF%9B%E7%A8%8B/os%E7%AC%AC%E4%B8%89%E7%AB%A07.jpg" alt="远程方法调用" title="远程方法调用"></p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS 线程</title>
      <link href="/2020/01/08/os%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/01/08/os%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>线程是CPU使用的基本单元，它由线程ID、程序计数器、寄存器集合和栈组成。它与同属一个进程的其他线程共享代码段、数据段和其他操作系统资源。<br><img src="/2020/01/08/os%E7%BA%BF%E7%A8%8B/os%E7%BA%BF%E7%A8%8B4.jpg" alt="单线程和多线程的区别" title="多线程和单线程的区别"></p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>有时候，一个应用程序可能需要执行多个相似的任务。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>1.响应度高</li><li>2.资源共享：线程默认共享它们所属进程的内存和资源。</li><li>3.经济：进程创建所需要的内存和资源的分配比较昂贵。</li><li>4.多处理器体系结构的利用：充分使用多处理器体系结构。<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2>两种方法：<blockquote><ul><li>用户层的用户线程：受内核支持，而无需内核管理。</li><li>内核层的内核线程：由操作系统直接支持和管理。</li></ul></blockquote><h3 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h3>将许多用户线程映射到一个内核线程。例如Green thread和<strong>GNU可移植线程（GNU Portable Thread）</strong>。效率比较高，但因为任一时刻只有一个线程能访问内核，多个线程不能并行运行在多处理器上。</li></ul><p><img src="/2020/01/08/os%E7%BA%BF%E7%A8%8B/os%E7%BA%BF%E7%A8%8B.jpg" alt="多对一模型" title="多对一模型"></p><h3 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h3><p>每个用户线程映射到一个内核线程。例如Linux和Windows操作系统家族。能够很好的实现并发功能，但因为创建内核线程的开销会影响应用程序的性能，所以会限制系统所支持的线程的数量。</p><p><img src="/2020/01/08/os%E7%BA%BF%E7%A8%8B/os%E7%BA%BF%E7%A8%8B1.jpg" alt="一对一模型" title="一对一模型"></p><h3 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h3><p>复用了许多用户线程到同样数量或更小的内核线程上。没有增加并发性，但不用担心线程过多且能并发执行。</p><p><img src="/2020/01/08/os%E7%BA%BF%E7%A8%8B/os%E7%BA%BF%E7%A8%8B2.jpg" alt="多对多模型" title="多对多模型"></p><h2 id="线程库（thread-library）"><a href="#线程库（thread-library）" class="headerlink" title="线程库（thread library）"></a>线程库（thread library）</h2><p>提供创建和管理线程的API。</p><p>实现线程库的两种方法：</p><blockquote><ul><li>在用户空间中提供一个没有内核支持的库，调用函数只是一个本地函数调用而不是系统调用。</li><li>执行一个由操作系统直接支持的内核级库，调用一个API通常会导致对内核的系统调用。</li></ul></blockquote><p>当前使用的三种主要的线程库：1.Pthread、2.Win32、3.Java。</p><h2 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h2><h3 id="系统调用fork-和exec"><a href="#系统调用fork-和exec" class="headerlink" title="系统调用fork()和exec()"></a>系统调用fork()和exec()</h3><h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p><strong>线程取消（thread cancellation）</strong>，在线程完成之前来终止线程的任务。要取消的线程通常称为目标线程。</p><blockquote><ul><li>1.异步取消（asynchronous cancellation）：一个线程立即终止目标线程。</li><li>2.延迟取消（deferred cancellation）：目标线程不断地检查它是否应终止，这允许目标线程有机会以有序方式来终结自己。</li></ul></blockquote><h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p>所有信号具有同样的模式</p><blockquote><ul><li>1.信号是由特事件的发生所产生的</li><li>2.产生信号要发送到线程</li><li>3一旦发送，信号必须加以处理</li></ul></blockquote><p>每个信号可能由两种可能的处理程序的一种来处理：</p><blockquote><p>1.<strong>默认信号处理程序（default signal handler）</strong>，每个程序都有一个默认信号处理程序<br>2.用户定义的信号处理程</p></blockquote><h3 id="线程池（thread-pool）"><a href="#线程池（thread-pool）" class="headerlink" title="线程池（thread pool）"></a>线程池（thread pool）</h3><p>优点：</p><blockquote><ul><li>通常用现有线程处理请求要比等待创建新的线程块</li><li>线程池限制了在任何时候可用线程的数量（由系统CPU的数量、物理内存的大小和并发客户请求的期望值等确定）</li></ul></blockquote><h3 id="线程特定数据（thread-specific-data）"><a href="#线程特定数据（thread-specific-data）" class="headerlink" title="线程特定数据（thread-specific data）"></a>线程特定数据（thread-specific data）</h3><p>同属一个进程的线程共享进程数据。不过一些线程在某些情况下需要一定数据的自己的副本。这些就称为线程特定数据。</p><h3 id="调度程序激活（scheduler-activation）"><a href="#调度程序激活（scheduler-activation）" class="headerlink" title="调度程序激活（scheduler activation）"></a>调度程序激活（scheduler activation）</h3><p>一种解决用户线程库与内核间通信的方法。内核提供一组虚拟处理器（轻量级进程，LWP）给应用程序，应用程序可调度用户线程到一个可用的LWP上。这样就为线程提供了一个用户级的中间系统，它就可以通过系统调用获得内核提供的服务。</p><p><img src="/2020/01/08/os%E7%BA%BF%E7%A8%8B/os%E7%BA%BF%E7%A8%8B3.jpg" alt="轻量级进程（LWP）" title="轻量级进程（LWP）"></p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS 操作系统结构</title>
      <link href="/2020/01/08/os%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
      <url>/2020/01/08/os%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><a id="more"></a><h2 id="操作系统服务"><a href="#操作系统服务" class="headerlink" title="操作系统服务"></a>操作系统服务</h2><h3 id="提供的函数"><a href="#提供的函数" class="headerlink" title="提供的函数"></a>提供的函数</h3><p>1.用户界面（user interface，UI）</p><blockquote><p>命令行界面（command-line interface，CLI）  采用文本命令，用一定的方法输入。<br>图形用户界面（graphical user interface，GUI）</p></blockquote><p>2.程序执行<br>3.I/O操作</p><blockquote><p>用户通常不能直接控制I/O设备，所以操作系统需要提供进行I/O操作的方法。</p></blockquote><p>4.文件系统操作</p><blockquote><p>程序需要读写文件和目录，也需要根据文件名来创建和删除文件、搜索一个给定的文件、列出文件信息。此外还包括基于文件所有权的允许或拒绝对文件或目录的访问管理</p></blockquote><p>5.通信</p><blockquote><p>一个进程需要与另一个进程交换信息。</p><blockquote><ol><li>同一台计算机上两个程序之间。</li><li>运行在网络连接起来的两台计算机上的进程之间。</li></ol></blockquote></blockquote><p>6.错误检测</p><blockquote><p>CPU或内存硬件、I/O设备和用户程序中出现的错误。</p></blockquote><p>7.资源分配</p><blockquote><p>同时有多个用户或多个作业运行时，系统必须为它们分配资源（CPU周期、内存、I/O设备等）。</p></blockquote><p>8.统计</p><blockquote><p>记录哪些用户使用了多少和什么类型的资源。</p></blockquote><p>9.保护和安全</p><blockquote><p>当多个程序并发时，一个程序不能干预另一个进程或操作系统本身。<br>同时系统也不能受到外界的侵犯。</p></blockquote><h2 id="操作系统用户界面"><a href="#操作系统用户界面" class="headerlink" title="操作系统用户界面"></a>操作系统用户界面</h2><h3 id="命令解释程序"><a href="#命令解释程序" class="headerlink" title="命令解释程序"></a>命令解释程序</h3><p>用于获取并执行用户指定的下一条命令。<br>1.命令解释程序本身包含代码以执行这些命令。<br>2.有系统程序实现绝大多数命令。</p><h3 id="图形用户界面（GUI）"><a href="#图形用户界面（GUI）" class="headerlink" title="图形用户界面（GUI）"></a>图形用户界面（GUI）</h3><p>提供基于鼠标的窗口和菜单系统。</p><h2 id="系统调用（system-call）"><a href="#系统调用（system-call）" class="headerlink" title="系统调用（system call）"></a>系统调用（system call）</h2><p>提供了操作系统提供的有效服务界面。应用程序开发人员根据<strong>应用程序接口</strong>（API）设计程序。组成API的函数就是操作系统提供的系统调用。</p><h2 id="系统调用类型"><a href="#系统调用类型" class="headerlink" title="系统调用类型"></a>系统调用类型</h2><ul><li>进程控制</li><li>文件管理</li><li>设备管理</li><li>信息维护</li><li>通信<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3>运行程序需要能够正常或非正常地中断其执行。<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3>创建和删除文件，读、写或重定位文件，确定和设置其属性（文件名、文件类型、保护模式、计账信息）。<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3>物理设备（磁带）抽象设备（文件）。<h3 id="信息维护"><a href="#信息维护" class="headerlink" title="信息维护"></a>信息维护</h3>用户程序和操作系统之间传递信息。<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3></li></ul><p>1.消息传递模型（message-passing model）</p><blockquote><p>通过彼此之间交换消息来交换信息。</p></blockquote><p>2.共享内存模型（shared-memory model）</p><blockquote><p>使用shared memory create和shared memoty attach 系统调用来获得其他进程所拥有的内存区域地访问权。</p></blockquote><h2 id="系统程序"><a href="#系统程序" class="headerlink" title="系统程序"></a>系统程序</h2><p>1.文件管理</p><blockquote><p>创建、删除、复制、重命名、打印、转储、列出和操作文件和目录。</p></blockquote><p>2.状态信息</p><blockquote><p>系统的日期、时间、可用内存、或磁盘空间的数量、用户数或类似的状态信息。</p></blockquote><p>3.文件修改<br>4.程序语言支持</p><blockquote><p>常用的程序设计语言的编译程序、汇编程序、调试程序和接师程序</p></blockquote><p>5.程序装入和执行<br>6.通信</p><h2 id="操作系统设计和实现"><a href="#操作系统设计和实现" class="headerlink" title="操作系统设计和实现"></a>操作系统设计和实现</h2><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>1.定义系统的目标和规格。<br>2.方便和容易使用、学习、可靠、安全和快速。<br>3.容易设计、实现和维护的同时灵活、可靠高效且没有错误。</p><h3 id="机制（mechanism）和策略（policy）"><a href="#机制（mechanism）和策略（policy）" class="headerlink" title="机制（mechanism）和策略（policy）"></a>机制（mechanism）和策略（policy）</h3><ul><li>机制   决定怎么做</li><li>策略   决定做什么<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3>使用汇编和高级语言编写<h2 id="操作系统结构-1"><a href="#操作系统结构-1" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><h3 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h3><img src="/2020/01/08/os%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/os%E7%AC%AC%E4%BA%8C%E7%AB%A01.png" alt="MS-DOS层次结构" title="MS-DOS层次结构"><h3 id="分层方法"><a href="#分层方法" class="headerlink" title="分层方法"></a>分层方法</h3>分层法   操作系统分成若干层。最底层为硬件，最高层为用户接口。<h3 id="微内核（microkernel）"><a href="#微内核（microkernel）" class="headerlink" title="微内核（microkernel）"></a>微内核（microkernel）</h3>将所有非基本部分从内核中移走，并将它们实现为系统程序或用户程序。从而使客户程序和运行在用户空间的各种服务之间进行通信。<br>好处：<blockquote><p>便于扩充操作系统。更好的安全性和可靠性。</p></blockquote></li></ul><p>坏处：</p><blockquote><p>由于系统功能总开销的增加而导致系统性能下降。</p></blockquote><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>面向对象编程技术生成模块化的内核。</p><h2 id="虚拟机（virtual-machine）"><a href="#虚拟机（virtual-machine）" class="headerlink" title="虚拟机（virtual machine）"></a>虚拟机（virtual machine）</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>底层机器的两种模式：用户模式和内核模式。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>优点是没有安全问题。但同时没有了资源共享。<br>共享实现的两种方法：</p><blockquote><p>1.通过共享小型磁盘来共享文件，模拟共享物理磁盘，用软件实现。<br>2.通过定义一个虚拟机的网络，模拟通信网络来传递消息。</p></blockquote><h2 id="系统生成（system-generation）"><a href="#系统生成（system-generation）" class="headerlink" title="系统生成（system generation）"></a>系统生成（system generation）</h2><p>对某个特定的计算机场所，配置和生成系统。</p><h2 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h2><p>装入内核以启动计算机的过程称为引导系统。步骤：</p><blockquote><p>一个简单的引导程序从磁盘上调入一个较复杂的引导程序。然后后者再装入内核</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS 导论</title>
      <link href="/2020/01/08/os%E5%AF%BC%E8%AE%BA/"/>
      <url>/2020/01/08/os%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><a id="more"></a><h2 id="操作系统做什么"><a href="#操作系统做什么" class="headerlink" title="操作系统做什么"></a>操作系统做什么</h2><h3 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h3><h4 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h4><p>中央处理单元（CPU）<br>内存（memory）<br>输入输出设备（IO）</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>系统程序<br>应用程序和用户</p><h3 id="用户视角"><a href="#用户视角" class="headerlink" title="用户视角"></a>用户视角</h3><h4 id="在大型机或小型机相连的终端前"><a href="#在大型机或小型机相连的终端前" class="headerlink" title="在大型机或小型机相连的终端前"></a>在大型机或小型机相连的终端前</h4><p>对资源使用做优化<br>确保所有的CPU时间、内存和I/O都能够得到充分使用，同时用户不会使用超出其权限以外的资源。</p><h4 id="在工作站前"><a href="#在工作站前" class="headerlink" title="在工作站前"></a>在工作站前</h4><p>个人使用性能和资源利用率的折中</p><h4 id="单个用户独立使用"><a href="#单个用户独立使用" class="headerlink" title="单个用户独立使用"></a>单个用户独立使用</h4><p>为了方便个人使用</p><h3 id="系统视角"><a href="#系统视角" class="headerlink" title="系统视角"></a>系统视角</h3><p>操作系统是控制程序</p><h3 id="定义操作系统"><a href="#定义操作系统" class="headerlink" title="定义操作系统"></a>定义操作系统</h3><p>管理计算机硬件并提供应用程序运行环境的软件</p><h2 id="计算机系统组织"><a href="#计算机系统组织" class="headerlink" title="计算机系统组织"></a>计算机系统组织</h2><h3 id="计算机系统操作"><a href="#计算机系统操作" class="headerlink" title="计算机系统操作"></a>计算机系统操作</h3><h4 id="引导程序（bootstrap-program）"><a href="#引导程序（bootstrap-program）" class="headerlink" title="引导程序（bootstrap program）"></a>引导程序（bootstrap program）</h4><p>计算机开始运行需要一个初始化程序</p><h4 id="中断（interrupt）"><a href="#中断（interrupt）" class="headerlink" title="中断（interrupt）"></a>中断（interrupt）</h4><h5 id="事件的发生"><a href="#事件的发生" class="headerlink" title="事件的发生"></a>事件的发生</h5><h5 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h5><p>通过系统总线向CPU发出信号</p><h5 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h5><p>系统调用（system call，监视器调用（monitor call））</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="随机访问内存（random-access-memory，RAM）"><a href="#随机访问内存（random-access-memory，RAM）" class="headerlink" title="随机访问内存（random access memory，RAM）"></a>随机访问内存（random access memory，RAM）</h4><p>计算机程序运行的地方</p><h4 id="动态随机访问内存（dynamic-random-access-memory，DRAM）"><a href="#动态随机访问内存（dynamic-random-access-memory，DRAM）" class="headerlink" title="动态随机访问内存（dynamic random access memory，DRAM）"></a>动态随机访问内存（dynamic random access memory，DRAM）</h4><p>处理器可以直接访问的唯一大容量存储区域</p><h4 id="指令寄存器（instruction-register）"><a href="#指令寄存器（instruction-register）" class="headerlink" title="指令寄存器（instruction register）"></a>指令寄存器（instruction register）</h4><h4 id="辅存（secondary-storage）"><a href="#辅存（secondary-storage）" class="headerlink" title="辅存（secondary storage）"></a>辅存（secondary storage）</h4><p>内存的扩充<br>磁盘（magnetic disk）</p><h3 id="I-O结构"><a href="#I-O结构" class="headerlink" title="I/O结构"></a>I/O结构</h3><h4 id="DMA（direct-memory-access，直接内存访问）"><a href="#DMA（direct-memory-access，直接内存访问）" class="headerlink" title="DMA（direct memory access，直接内存访问）"></a>DMA（direct memory access，直接内存访问）</h4><p>解决大块数据移动</p><h2 id="计算机系统体系结构"><a href="#计算机系统体系结构" class="headerlink" title="计算机系统体系结构"></a>计算机系统体系结构</h2><h3 id="单处理器系统"><a href="#单处理器系统" class="headerlink" title="单处理器系统"></a>单处理器系统</h3><p>只有一个主CPU能够执行一个通用指令集</p><h3 id="多处理器系统（并行系统（parallel-system）或紧耦合系统（tightly-coupled-system））"><a href="#多处理器系统（并行系统（parallel-system）或紧耦合系统（tightly-coupled-system））" class="headerlink" title="多处理器系统（并行系统（parallel system）或紧耦合系统（tightly coupled system））"></a>多处理器系统（并行系统（parallel system）或紧耦合系统（tightly coupled system））</h3><h4 id="有多个紧密通信的CPU"><a href="#有多个紧密通信的CPU" class="headerlink" title="有多个紧密通信的CPU"></a>有多个紧密通信的CPU</h4><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>增加吞吐量<br>规模经济<br>增加可靠性</p><h4 id="非对称对处理"><a href="#非对称对处理" class="headerlink" title="非对称对处理"></a>非对称对处理</h4><h4 id="对称多处理"><a href="#对称多处理" class="headerlink" title="对称多处理"></a>对称多处理</h4><h3 id="集群系统（clustered-system）"><a href="#集群系统（clustered-system）" class="headerlink" title="集群系统（clustered system）"></a>集群系统（clustered system）</h3><p>提供高可用性服务</p><h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><h3 id="最重要的是有多道程序设计"><a href="#最重要的是有多道程序设计" class="headerlink" title="最重要的是有多道程序设计"></a>最重要的是有多道程序设计</h3><p>分时系统<br>交互计算机系统</p><h3 id="作业池（job-pool）"><a href="#作业池（job-pool）" class="headerlink" title="作业池（job pool）"></a>作业池（job pool）</h3><p>作业调度（job scheduling）</p><h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><h3 id="虚拟内存（virtual-memory）"><a href="#虚拟内存（virtual-memory）" class="headerlink" title="虚拟内存（virtual memory）"></a>虚拟内存（virtual memory）</h3><p>逻辑内存（logical memory）</p><h3 id="物理内存（physical-memory）"><a href="#物理内存（physical-memory）" class="headerlink" title="物理内存（physical memory）"></a>物理内存（physical memory）</h3><h2 id="操作系统操作"><a href="#操作系统操作" class="headerlink" title="操作系统操作"></a>操作系统操作</h2><h3 id="双重模式操作"><a href="#双重模式操作" class="headerlink" title="双重模式操作"></a>双重模式操作</h3><p>用户模式（user mode）</p><blockquote><p>用户应用程序运行的时候系统处于的模式。</p></blockquote><p>监督程序模式（monitor mode），也称管理模式（supervisor mode）、系统模式（system mode）和特权模式（privileged mode）</p><blockquote><p>用来执行系统服务，只有在内核模式的时候才能执行特权指令。</p></blockquote><p>模式位（mode bit）</p><blockquote><p>标识所处的状态</p></blockquote><p>特权指令（privileged mode）</p><blockquote><p>能够引起损害的机器指令</p></blockquote><h3 id="定时器（timer）"><a href="#定时器（timer）" class="headerlink" title="定时器（timer）"></a>定时器（timer）</h3><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>程序计数器</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><h3 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h3><p>创建和删除文件<br>创建和删除目录来组织文件<br>提供操作文件和目录的原语<br>将文件映射到二级存储上<br>在稳定存储介质上备份文件</p><h3 id="大容量存储器管理"><a href="#大容量存储器管理" class="headerlink" title="大容量存储器管理"></a>大容量存储器管理</h3><p>空闲空间管理<br>存储空间分配<br>磁盘调度</p><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>高速缓存一致性（cache coherency）<br>需要特定信息时，首先检查是否在高数缓存中。如果不在，使用位于内存中的信息。</p><h3 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h3><p>一个包括缓冲、高速缓存和假脱机的内存管理部分<br>通用的设备驱动器接口<br>特定硬件设备的驱动程序</p><h2 id="保护和安全"><a href="#保护和安全" class="headerlink" title="保护和安全"></a>保护和安全</h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>一种控制进程或用户对计算机系统资源的访问的机制</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>防止系统不受外部或内部攻击</p><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><p>局域网（local-area network，LAN）<br>广域网（wide-area network，WAN）<br>域域网（metropoltan-area network）<br>小域网（small-area network）</p><h2 id="专用系统"><a href="#专用系统" class="headerlink" title="专用系统"></a>专用系统</h2><h3 id="实时嵌入式系统"><a href="#实时嵌入式系统" class="headerlink" title="实时嵌入式系统"></a>实时嵌入式系统</h3><p>实时操作系统<br>当对处理器操作或数据流动有严格时间要求时，就需要使用实时系统。</p><h3 id="多媒体系统"><a href="#多媒体系统" class="headerlink" title="多媒体系统"></a>多媒体系统</h3><p>用来处理传统的数据</p><h3 id="手持系统（handheld-system）"><a href="#手持系统（handheld-system）" class="headerlink" title="手持系统（handheld system）"></a>手持系统（handheld system）</h3><h2 id="计算环境"><a href="#计算环境" class="headerlink" title="计算环境"></a>计算环境</h2><h3 id="传统计算"><a href="#传统计算" class="headerlink" title="传统计算"></a>传统计算</h3><h3 id="客户机-服务器计算"><a href="#客户机-服务器计算" class="headerlink" title="客户机-服务器计算"></a>客户机-服务器计算</h3><h4 id="服务器系统（server-system）"><a href="#服务器系统（server-system）" class="headerlink" title="服务器系统（server system）"></a>服务器系统（server system）</h4><p>计算服务器<br>提供接口以接受用户所发出的执行操作的请求，执行操作，并将操作结果反回给客户机。<br>文件服务器系统<br>提供文件系统接口，以便客户机能创建、更新、访问和删除文件。</p><h4 id="客户机系统（client-system）"><a href="#客户机系统（client-system）" class="headerlink" title="客户机系统（client system）"></a>客户机系统（client system）</h4><h3 id="对等计算"><a href="#对等计算" class="headerlink" title="对等计算"></a>对等计算</h3><p>p2p</p><h3 id="基于web的计算"><a href="#基于web的计算" class="headerlink" title="基于web的计算"></a>基于web的计算</h3>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome</title>
      <link href="/2020/01/08/hello-world/"/>
      <url>/2020/01/08/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎参观我的博客"><a href="#欢迎参观我的博客" class="headerlink" title="欢迎参观我的博客"></a><center>欢迎参观我的博客</center></h1><center>我会不定期在这里更新一些我的学习总结和一些摄影作品，希望你能够喜欢！<center><!-- ## Quick Start### Create a new post<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a> –&gt;</p>--></center></center>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS 文件系统实现</title>
      <link href="/2020/01/06/os%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/01/06/os%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h1><a id="more"></a><h2 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h2><p>磁盘提供大量的外存空间来维持文件系统。它有以下两个特点：</p><ul><li>可以原地重写，可以从磁盘上读一块，修改该块，并将它写回到原来位置。</li><li>可以直接访问磁盘上的任意一块信息。</li></ul><p><img src="/2020/01/06/os%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/os%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B01.jpg" alt="分层设计的文件系统" title="分层设计的文件系统"></p><p>I/O控制为最底层，由设备驱动程序和中断处理程序组成。</p><p>基本文件系统只需要向合适的设备驱动程序发送一般命令就可对磁盘上的物理块进行读写。</p><p>文件组织模块（file-organization module）知道文件及其逻辑块和物理块</p><p>逻辑文件系统管理元数据（文件系统的所有结构数据）。</p><p>文件控制块（file control block，FCB）包含文件的信息。</p><h2 id="文件系统实现-1"><a href="#文件系统实现-1" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><strong>引导控制块（boot control block）</strong>包括系统从改卷引导操作系统所需要的信息。</li><li><strong>卷控制块（volume control block）</strong>包括卷（或分区）的详细信息。</li><li>每个文件系统的目录结构用来组织文件。</li><li>每个文件的FCB包括很多该文件的详细信息。<h3 id="分区和安装"><a href="#分区和安装" class="headerlink" title="分区和安装"></a>分区和安装</h3>生的分区（raw）没有文件系统，熟的分区（cooked）有文件系统。根分区（root）包括操作系统内核或其他系统文件。<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><img src="/2020/01/06/os%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/os%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B02.jpg" alt="虚拟文件系统示意图" title="虚拟文件系统示意图"></li></ul><p>第一层文件系统接口</p><p>第二层虚拟文件系统（VFS）层。通过定义一个清晰的VFS接口，将文件系统的通用性和具体实现分开。提供了在网络上唯一标识一个文件的机制。Linux中VFS定义的4种对象类型：</p><blockquote><ul><li><strong>索引节点对象（inode object）</strong>，表示一个单独的文件</li><li><strong>文件对象（file object）</strong>，表示一个打开的文件</li><li><strong>超级块对象（superblock object）</strong>，表示整个文件系统</li><li><strong>目录条目对象（dentry object）</strong>，表示要给单独的目录条目</li></ul></blockquote><p>第三层实现文件系统类型或远程文件系统协议</p><h2 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h2><h3 id="线性列表"><a href="#线性列表" class="headerlink" title="线性列表"></a>线性列表</h3><p>使用存储文件名和数据块指针的线性列表。编程简单但是运行费事。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>使用哈希数据结构。大大减少了目录搜索时间，但是要避免冲突。</p><h2 id="分配方法"><a href="#分配方法" class="headerlink" title="分配方法"></a>分配方法</h2><h3 id="连续分配（contiguous-allocation）"><a href="#连续分配（contiguous-allocation）" class="headerlink" title="连续分配（contiguous allocation）"></a>连续分配（contiguous allocation）</h3><p>要求每个文件在磁盘上占有一组连续的块。磁盘地址为磁盘定义了一个线性序列。困难是为新文件找到空间。是动态存储分配的一个具体应用。</p><h3 id="链接分配（linked-allocation）"><a href="#链接分配（linked-allocation）" class="headerlink" title="链接分配（linked allocation）"></a>链接分配（linked allocation）</h3><p>解决了连续分配的问题，每个文件是磁盘的链表。但是它只能顺序访问。</p><p>通过文件分配表（FAT）的使用。解决顺序访问的问题。</p><h3 id="索引分配（indexed-allocation）"><a href="#索引分配（indexed-allocation）" class="headerlink" title="索引分配（indexed allocation）"></a>索引分配（indexed allocation）</h3><p>通过把所有指针放在一起，解决不能随机访问和直接访问的问题。每个文件都有一个索引块，是一个磁盘块地址的数组。索引分配支持直接访问，且没有外部碎片的问题。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>连续分配访问一次就能得到磁盘块。链接分配对于直接访问效率很低。索引分配更为复杂，使用的时候需要一大块空间。</p><h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><p>为了记录空闲空间，系统需要一个空闲空间链表（free-space list）。</p><h3 id="位向量（bit-vector）"><a href="#位向量（bit-vector）" class="headerlink" title="位向量（bit vector）"></a>位向量（bit vector）</h3><p>用一个标记位来表示块是否使用。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>将所有空闲磁盘块用链表连接起来，并将指向第一空闲块的指针保存在磁盘的特殊位置，同时也缓存在内存中。</p><h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>将n个空闲块的地址存在当一个空闲块中。</p><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>记录第一块的地址和紧跟着第一块的连续的空间块的数量n。</p><h2 id="效率和性能"><a href="#效率和性能" class="headerlink" title="效率和性能"></a>效率和性能</h2><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>磁盘空间的有效使用主要取决于所使用的磁盘分配和目录管理算法。</p><h3 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h3><p>有的系统有一块独立内存用作缓冲缓存；有的采用页面缓存（page cache）；有的采用虚拟地址来缓存文件数据（统一虚拟内存（unified virtual memory））；使用双重缓存（double caching）：页面缓存和缓冲缓存。</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><h3 id="一致性检查（consistency-checker）"><a href="#一致性检查（consistency-checker）" class="headerlink" title="一致性检查（consistency checker）"></a>一致性检查（consistency checker）</h3><p>将目录结构数据与磁盘数据块相比较，并试图纠正所发现的不一致。</p><h3 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h3><p>将数据备份到另一个存储设备，需要的时候只需要从备份中恢复就可以。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS 文件系统接口</title>
      <link href="/2020/01/06/os%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/01/06/os%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统接口"><a href="#文件系统接口" class="headerlink" title="文件系统接口"></a>文件系统接口</h1><a id="more"></a><h2 id="文件概念"><a href="#文件概念" class="headerlink" title="文件概念"></a>文件概念</h2><p>文件是记录在外存上的相关信息的具有名称的集合。</p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>所有文件的信息都保存在目录结构中。</p><ul><li>名称</li><li>标识符：系统内文件的唯一标签，不可读。</li><li>类型</li><li>位置：指向设备和设备上文件位置的指针。</li><li>大小</li><li>保护</li><li>时间、日期和用户标识：文件创建、上次修改和上次访问的相关信息。<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3>文件是抽象数据类型。主要操作有：</li><li>创建文件</li><li>写文件</li><li>读文件</li><li>在文件内重定位</li><li>删除文件</li><li>截短文件</li></ul><p>每个打开文件有如下相关信息：</p><ul><li>文件指针</li><li>文件打开计数器</li><li>文件磁盘位置</li><li>访问权限</li></ul><p>有的文件提供一个文件锁。例如提供给读者的共享锁（shared lock），提供给写者的专用锁（exclusive lock）。另外操作系统提供强制（mandatory）或建议（advisory）文件加锁机制。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>文件名称包括两部分：<strong>名称</strong>和<strong>扩展名</strong>。其中扩展名就表明了文件的类型。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件结构也可以用文件类型表示。</p><h3 id="内部文件结构"><a href="#内部文件结构" class="headerlink" title="内部文件结构"></a>内部文件结构</h3><h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><h3 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h3><p>文件信息按顺序，一个记录接着一个记录地加以处理。</p><p>顺序访问基于文件的磁带模型。</p><h3 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h3><p>也称相对访问。文件由固定长度地逻辑记录组成，允许程序按任意顺序进行快速读写。文件可作为块或记录的编号序列。因此可以直接读取某个块，在直接读取时，读写顺序是没有限制的。</p><p>直接访问基于文件的磁带模型</p><h3 id="其他访问方式"><a href="#其他访问方式" class="headerlink" title="其他访问方式"></a>其他访问方式</h3><p>其他访问方式基于直接访问方式。通过建立索引，再访问文件。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>磁盘可以整体的用于一个文件系统。但是有时候需要装上多种文件系统。这些部分称为分区或片，也称小型磁盘。这些部分可以组合成一个更大的空间，卷（volume）。文件的信息保存在设备目录或卷表中。</p><h3 id="文件概述"><a href="#文件概述" class="headerlink" title="文件概述"></a>文件概述</h3><p>目录可以看作符号表，它能将文件名称转换成目录条目。</p><p>相关操作：</p><ul><li>搜索文件</li><li>创建文件</li><li>删除文件</li><li>遍历目录</li><li>重命名文件</li><li>跟踪文件系统<h3 id="单层结构目录"><a href="#单层结构目录" class="headerlink" title="单层结构目录"></a>单层结构目录</h3>所有文件都包含在同一目录。特点是便于理解和支持。<h3 id="双层结构目录"><a href="#双层结构目录" class="headerlink" title="双层结构目录"></a>双层结构目录</h3>在双层结构目录中，每个用户都有自己的用户文件目录（user file directory，UFD）。当一个用户作业开始执行或一个用户注册是，就搜索系统的主文件目录（master file directory，MFD）。<h3 id="树状结构目录"><a href="#树状结构目录" class="headerlink" title="树状结构目录"></a>树状结构目录</h3>对前面的推广，用户又创建自己的子目录。这时就有了路径：绝对路径和相对路径。绝对路径从根开始并给出路径上的目录名。相对路径从当前目录开始定义路径。<h3 id="无环图目录"><a href="#无环图目录" class="headerlink" title="无环图目录"></a>无环图目录</h3>共享子目录或文件可同时位于文件系统的两（或多）处。</li></ul><p>树状图禁止共享文件和目录，而无环图（acyclic graph）可以</p><h3 id="通用图目录"><a href="#通用图目录" class="headerlink" title="通用图目录"></a>通用图目录</h3><p>无环的优点是可以用简单的算法遍历图，并确定是否存在文件引用。建立通用的图原因时性能原因。</p><h2 id="文件系统安装"><a href="#文件系统安装" class="headerlink" title="文件系统安装"></a>文件系统安装</h2><p>文件系统在使用之前必须安装（mount）。安装的时候需要一个安装点（mount point），通常为空目录。</p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><h3 id="多用户"><a href="#多用户" class="headerlink" title="多用户"></a>多用户</h3><p>当一个操作系统有多个用户时，对于允许用户共享文件的目录结构，系统必须控制文件共享。</p><h3 id="远程文件系统"><a href="#远程文件系统" class="headerlink" title="远程文件系统"></a>远程文件系统</h3><p>在网络上的文件系统有三种实现方式：一时用户通过程序可实现在机器之间进行文件的人工传输（允许匿名访问）。二是用分布式文件系统（DFS），远程目录可从本机上直接访问。三是通过万维网的网站进行访问（和第一种类似）。</p><h4 id="客户机-服务器模型"><a href="#客户机-服务器模型" class="headerlink" title="客户机-服务器模型"></a>客户机-服务器模型</h4><p>远程文件系统允许一台计算机安装一台或多台远程机器上的一个或多个文件系统。这种情况下，包含文件的机器称为服务器，访问文件的称为客户机。客户机可通过网络访问，但是可能被欺骗。未经验证的客户机可能欺骗服务器进入服务器。</p><h4 id="分布式信息系统"><a href="#分布式信息系统" class="headerlink" title="分布式信息系统"></a>分布式信息系统</h4><p>也成为分布式命名服务，用来体统用于远程计算所需的信息的统一访问。域名系统（DNS）为网络提供了主机名称到网络地址的转换。</p><h4 id="故障模式"><a href="#故障模式" class="headerlink" title="故障模式"></a>故障模式</h4><p>本地文件系统可能因各种原因出错如元素据（metadata）的损坏、磁盘控制器故障等。</p><h3 id="一致性语义（consistency-semantics）"><a href="#一致性语义（consistency-semantics）" class="headerlink" title="一致性语义（consistency semantics）"></a>一致性语义（consistency semantics）</h3><p>评估文件系统对文件共享支持的一个重要准则。它是描述多用户同时访问共享文件时的语义，规定了一个用户所修改的数据何时对另一个用户可见。</p><h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p>保证数据不受物理损坏和非法访问。</p><h3 id="访问类型"><a href="#访问类型" class="headerlink" title="访问类型"></a>访问类型</h3><p>控制访问（controlled access）有以下几种类型：</p><ul><li>读</li><li>写</li><li>执行</li><li>添加：将新信息添加到文件结尾部分</li><li>删除</li><li>列表清单：列出文件名称及其属性<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3>根据用户的身份来控制。所以可以增加一个访问控制列表（access-control list，ACL），给每个用户名设定所允许的访问类型。</li></ul><p>通常设定三个用户类型：</p><ul><li>拥有者</li><li>组：一组需要共享文件且有类似访问的用户形成同一组用户组。</li><li>其他<h3 id="其他保护方式"><a href="#其他保护方式" class="headerlink" title="其他保护方式"></a>其他保护方式</h3>给文件加上密码。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS 死锁</title>
      <link href="/2020/01/06/os%E6%AD%BB%E9%94%81/"/>
      <url>/2020/01/06/os%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>如果一组进程中每一个进程都处于等待状态，而这一事件只能由这一组进程的另一进程引起，那么这组进程将永远处于等待状态。这种情况就称为<strong>死锁（deadlock）</strong>。</p><a id="more"></a><h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p>进程在使用资源前必须申请资源，在使用资源之后必须释放资源。在正常操作模式下，进程只能按如下顺序使用资源：</p><ol><li>申请：如果申请不被允许，那么进程必须等待，直到它获得该资源为止。</li><li>使用：对资源进行操作。</li><li>释放：使用完后释放资源。</li></ol><p>资源的申请与释放为系统调用。</p><h2 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ol><li><strong>互斥</strong>：至少有一个资源一次只有一个进程可以使用。</li><li><strong>占有并等待</strong>：一个进程必须占有至少一个资源并等待另一个资源，而该资源为其他进程占有。</li><li><strong>非抢占</strong>：资源不能被抢占</li><li><strong>循环等待</strong>：有一组等待进程{P₀，P₁，…，Pn}，P₀等待的资源为P₁所占有，P₁等待的资源为P₂所占有，…，Pn-1等待的资源为Pn所占有，Pn等待的资源为P₀所占有。</li></ol><p>必须这四个条件同时出现才会出现死锁。</p><h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><p>P-&gt;R为申请边，R-&gt;P为分配边。</p><p><img src="/2020/01/06/os%E6%AD%BB%E9%94%81/os%E6%AD%BB%E9%94%811.jpg" alt="资源分配图" title="资源分配图"></p><h3 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h3><p>从原理上来说有三种：</p><blockquote><ol><li>可使用协议以预防或避免死锁，确保系统不会进入死锁状态。</li><li>可允许系统进入死锁状态，然后检测它，并加以恢复。</li><li>可忽视这个问题，认为死锁不可能在系统内发生。</li></ol></blockquote><h4 id="采用死锁预防（deadlock-prevention）的方案"><a href="#采用死锁预防（deadlock-prevention）的方案" class="headerlink" title="采用死锁预防（deadlock prevention）的方案"></a>采用死锁预防（deadlock prevention）的方案</h4><p>确保至少一个必要条件（互斥、占有并等待、非抢占和循环等待）不成立。</p><h4 id="采用死锁避免（deadlock-avoidance）的方案"><a href="#采用死锁避免（deadlock-avoidance）的方案" class="headerlink" title="采用死锁避免（deadlock avoidance）的方案"></a>采用死锁避免（deadlock avoidance）的方案</h4><p>事先得到有关进程申请资源和使用资源的额外信息。然后确定该进程是否应该等待，是允许申请还是延迟。</p><h2 id="死锁避免（deadlock-avoidance）"><a href="#死锁避免（deadlock-avoidance）" class="headerlink" title="死锁避免（deadlock avoidance）"></a>死锁避免（deadlock avoidance）</h2><h3 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h3><p>如果系统能按某个顺序为每个进程分配资源并能避免死锁，那么系统状态就是安全的。即如果存在一个安全序列，那么系统处于安全状态。</p><h3 id="资源分配图算法"><a href="#资源分配图算法" class="headerlink" title="资源分配图算法"></a>资源分配图算法</h3><p>除了申请边和分配边外，引入需求边。假设进程i申请资源j。只有在将申请边i-&gt;j变成分配边j-&gt;i而不会导致资源分配图形成环时，才允许申请。</p><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>资源分配图算法不适合于每种资源类型有多个实例的资源分配系统。在银行家算法中，如果客户的需求不能满足，银行决不会分配其现金。<br>死锁避免的资源分配图</p><p><img src="/2020/01/06/os%E6%AD%BB%E9%94%81/os%E6%AD%BB%E9%94%812.jpg" alt="死锁避免的资源分配图" title="死锁避免的资源分配图"></p><p>资源分配图的不安全状态</p><p><img src="/2020/01/06/os%E6%AD%BB%E9%94%81/os%E6%AD%BB%E9%94%813.jpg" alt="资源分配图的不安全状态" title="资源分配图的不安全状态"></p><p>所需数据结构：</p><blockquote><ul><li><strong>Availabe</strong>：长度为m的向量，表示每种资源的现有实例的数量。</li><li><strong>Max</strong>：n*m矩阵，定义每个进程的最大需求。</li><li><strong>Allocation</strong>：n*m矩阵，定义每个进程现在所分配的各种资源类型的实例数量。</li><li><strong>Need</strong>：n*m矩阵，表示每个进程还需要的剩余的资源。</li></ul></blockquote><h4 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h4><p>步骤：</p><p>1.设work和finish分别为长度m和n的向量。work=available，finish[0,…,n-1]=false。</p><p>2.查找这样的i使其满足</p><blockquote><ol><li>finish[i]=false</li><li>need[i]≤work</li></ol></blockquote><p>如果没有就跳转到第4步。</p><p>3.work=work+allocation[i];finish[i]=true<br>返回到第2步</p><p>4.如果对所有i，finish[i]=true，那么系统处于安全状态。</p><h4 id="资源请求算法"><a href="#资源请求算法" class="headerlink" title="资源请求算法"></a>资源请求算法</h4><p>request[i]为进程P[i]的请求向量。request[j]==k表示进程P[i]需要资源类型为j的实例数量为k。步骤：</p><ol><li>如果request[i]≤need[i]，那么调转到第2步。否则报错：进程所需资源超过最大请求。</li><li>如果request[i]≤available,那么跳转到第3步。否则报错：进程所需资源超过现有资源。</li><li>分配资源：<blockquote><ol><li>available=available-request[i];</li><li>allocation[i]=allocation[i]+request[i];</li><li>need[i]=need[i]-request[i];</li></ol></blockquote></li></ol><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>系统提供：</p><ul><li>一个用来检查系统状态从而确定是否出现了死锁的算法</li><li>一个用来从死锁状态中恢复的算法<h3 id="每个资源类型只有单个实例"><a href="#每个资源类型只有单个实例" class="headerlink" title="每个资源类型只有单个实例"></a>每个资源类型只有单个实例</h3>如果每个资源类型只有单个实例，那就删除所有资源实例就能得到一个等待图（wait-for）。只要图中没有环就不会出现死锁。<h3 id="每种资源类型可有多个实例"><a href="#每种资源类型可有多个实例" class="headerlink" title="每种资源类型可有多个实例"></a>每种资源类型可有多个实例</h3>和银行家算法中的安全性算法相同。<h3 id="应用检测算法"><a href="#应用检测算法" class="headerlink" title="应用检测算法"></a>应用检测算法</h3>当经常发生死锁时，就应经常调用应用检测算法。但经常调用应用检测算法会增加开销。<h2 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h2><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3>两种终止方法：</li><li>终止所有死锁进程。代价较高。</li><li>一次只终止一个进程直到取消死锁循环为止。开销较大。<h3 id="资源抢占"><a href="#资源抢占" class="headerlink" title="资源抢占"></a>资源抢占</h3>通过逐步从其他进程中抢占资源直到死锁打破。但是也有问题：</li></ul><ol><li>选择一个牺牲品</li><li>回滚：被抢占资源的进程回到一个安全的状态</li><li>饥饿：保证每次被抢占的不是同一个进程</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS 进程同步</title>
      <link href="/2020/01/06/os%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2020/01/06/os%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="OS-进程同步"><a href="#OS-进程同步" class="headerlink" title="OS 进程同步"></a>OS 进程同步</h1><p>多个进程对同一数据处理且执行结果与访问顺序有关，称为竞争条件（race condition）。这就是<strong>进程同步（process synchronization）</strong>和<strong>协调（coordination）</strong>问题。</p><a id="more"></a><h2 id="临界区问题（critical-section-problem）"><a href="#临界区问题（critical-section-problem）" class="headerlink" title="临界区问题（critical-section problem）"></a>临界区问题（critical-section problem）</h2><ul><li><p><strong>临界区（critical section）</strong>可能改变共同变量、更新一个表、写一个文件等的代码段。</p></li><li><p><strong>进入区（entry section）</strong>每个进程请求允许进入临界区的代码段</p></li><li><p><strong>退出区（exit section）</strong>退出临界区的代码段</p></li><li><p><strong>剩余区（remainder section）</strong>其他代码段</p><h3 id="临界区问题的解答的三个要求"><a href="#临界区问题的解答的三个要求" class="headerlink" title="临界区问题的解答的三个要求"></a>临界区问题的解答的三个要求</h3></li><li><p>互斥（mutual exclusion）</p><blockquote><ul><li>如果有进程在临界区执行，其他进程就不能进入。</li></ul></blockquote></li><li><p>前进（progress）</p><blockquote><ul><li>如果没有进程在其临界区执行，且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可参加选择确定下一个进入临界区的程序，且这个过程不能无限推迟。</li></ul></blockquote></li><li><p>有限等待（bounded waiting）</p><blockquote><ul><li>从一个进程做出进入临界区的请求直到该请求允许为止，其他进程允许进入其临界区的次数有上限。</li></ul></blockquote></li></ul><h4 id="两种用于处理操作系统内临界区问题的方法"><a href="#两种用于处理操作系统内临界区问题的方法" class="headerlink" title="两种用于处理操作系统内临界区问题的方法"></a>两种用于处理操作系统内临界区问题的方法</h4><p>抢占内核（preemptive kernel）<br>允许处于内核模式的进程被抢占</p><p>非抢占内核（nonpreemtive kernel）<br>不允许处于内核模式的进程被抢占</p><h2 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><p>这是一个经典的基于软件的临界区问题的解答</p><p>算法在两个进程之间共享两个数据项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> turn;<span class="comment">//表示哪个进程可以进入其临界区</span></span><br><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];<span class="comment">//表示哪个进程想要进入临界区</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/06/os%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/os%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A51.jpg" alt="Peterson算法中的进程P的结构" title="Peterson算法中的进程P的结构"></p><h2 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h2><p>用一个锁来实现同步。即一个进程在进入临界区之前必须得到锁，而在其退出临界区时释放锁。</p><p><img src="/2020/01/06/os%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/os%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A52.jpg" alt="采用锁的临界区问题的解答" title="采用锁的临界区问题的解答"></p><p>在单处理器上这个问题可以简单的解决（在修改共享变量时禁止中断出现）。但是在多处理器上不可行。于世界提供了特殊迎接指令以允许能够原子地（不可中断地）检查和修改字的内容或交换两个字的内容。</p><p>使用TestAndSet()的有限等待互斥示例：</p><p>公用数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool waiting[n];</span><br><span class="line">bool lock;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/06/os%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/os%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A53.jpg" alt="使用TestAndSet的有限等待互斥" title="使用TestAndSet的有限等待互斥"></p><h2 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h2><p>通过两个标准原子操作：<strong>wait()</strong>（P（proberen，测试））和<strong>signal()</strong>（V（verhogen，增加））来访问。</p><p>wait()的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S&lt;=<span class="number">0</span>)</span><br><span class="line">    ;<span class="comment">//no-op</span></span><br><span class="line">    S--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signal()的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S)&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>计数信号量的值域不受限制，而二进制信号量的值只能为0或1。有的系统将二进制信号量成为互斥锁。</p><p><img src="/2020/01/06/os%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/os%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A54.jpg" alt="使用信号量的互斥实现" title="使用信号量的互斥实现"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>信号量的主要缺点是——都要求忙等待（busy waiting）。这种连续地循环地方式也称为自旋锁（spinlock）。</p><p>为了解决忙等可以修改信号量操作wait()和signal()的定义。当执行wait()操作时如果发现信号量值不为正，则阻塞自己，这个阻塞操作将进程放入到于信号量相关的等待队列中，并将该进程的状态切换成等待状态。然后在其它进程执行signal()操作后使用wakeup()操作来进行重新执行。</p><p>这里将信号量定义为以下结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">list</span>;</span><span class="comment">//可以使用进程控制块中的一个链接域来实现</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure><p>wait()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        add <span class="keyword">this</span> process to S-&gt;<span class="built_in">list</span>;</span><br><span class="line">        block();<span class="comment">//用block()挂起进程P</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signal()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        remove a process from S-&gt;<span class="built_in">list</span>;</span><br><span class="line">        wakeup(P);<span class="comment">//用wakeup(P)重新启动进程P</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SMP系统必须提供其他加锁技术，以确保两个操作可以原子地执行。在这里的wait()和signal()并没有完全取消忙等，是取消了进入临界区的忙等，而且将忙等限制在临界区内。</p><h3 id="死锁（deadlock）和饥饿（starvation）"><a href="#死锁（deadlock）和饥饿（starvation）" class="headerlink" title="死锁（deadlock）和饥饿（starvation）"></a>死锁（deadlock）和饥饿（starvation）</h3><p>当两个或多个进程无限的等待一个事件，而这个事件只能由这些进程产生，这些进程就称为死锁。与之相关的问题是无限期阻塞（indefinite blocking）和饥饿（starvation）。</p><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><p>采用信号量作为同步问题的解答。</p><h3 id="有限缓冲问题（生产者消费者问题）"><a href="#有限缓冲问题（生产者消费者问题）" class="headerlink" title="有限缓冲问题（生产者消费者问题）"></a>有限缓冲问题（生产者消费者问题）</h3><p>假定缓冲池有n个缓冲项，每个缓冲项能存一个数据项。信号量mutex提供了对缓冲池访问的扶持要求，并初始化为1。信号量empty和full分别用来表示空缓冲项和满缓冲项的个数。信号量empty初始化为n；full初始化为0。</p><p>生产者进程结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//produce an item nextp</span></span><br><span class="line">    ...</span><br><span class="line">    wait(empty);</span><br><span class="line">    wait(mutex);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//add nextp to buffer</span></span><br><span class="line">    ...</span><br><span class="line">    signal(mutex);</span><br><span class="line">    signal(full);</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>消费者进程结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    wait(full);</span><br><span class="line">    wait(mutex);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//remove an item from buffer to nextc</span></span><br><span class="line">    ...</span><br><span class="line">    signal(mutex);</span><br><span class="line">    signal(empty);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//consume an item in nextc</span></span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>一个数据库可以为多个并发进程所共享。大致可分为读者（只需要读数据库）写者（可能要更新数据库）。第一读者-写者问题：读者优先；第二读者-写者问题：写者优先。它们都会造成饥饿问题。这里演示第一读者-写者问题：</p><p>数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex,wrt;<span class="comment">//wrt为读者和写者共用（写者互斥），mutex确保互斥</span></span><br><span class="line"><span class="keyword">int</span> readcount;<span class="comment">//读者的计数</span></span><br></pre></td></tr></table></figure><p>写者进程结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    wait(wrt);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//writing is performed</span></span><br><span class="line">    ...</span><br><span class="line">    signal(wrt);</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>读者进程结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    wait(mutex);<span class="comment">//需要保证if语句块中的代码能够执行，下同</span></span><br><span class="line">    readcount++;</span><br><span class="line">    <span class="keyword">if</span>( readcount == <span class="number">1</span>)</span><br><span class="line">        wait(wrt);<span class="comment">//一旦有读者，就和写者就无法进入</span></span><br><span class="line">    signal(mutex);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//reading is performed</span></span><br><span class="line">    ...</span><br><span class="line">    wait(mutex);</span><br><span class="line">    readcount--;</span><br><span class="line">    <span class="keyword">if</span>( readcount == <span class="number">0</span>)</span><br><span class="line">        signal(wrt);<span class="comment">//所有读者都读完后唤醒写者</span></span><br><span class="line">    signal(mutex);</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这种问题在一下场景适合</p><blockquote><ul><li>当可以区分进程是读还是写数据</li><li>读者进程比写者进程多时（第一读者-写者问题）</li></ul></blockquote><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>n哲学家进餐问题描述有五个哲学家，他们的生活方式是交替地进行思考和进餐，n哲学家们共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子，n平时哲学家进行思考，饥饿时便试图取其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐，n进餐完毕，放下筷子又继续思考。</p><h4 id="第一种解法——每只筷子都用一个信号量来表示（会造成死锁）"><a href="#第一种解法——每只筷子都用一个信号量来表示（会造成死锁）" class="headerlink" title="第一种解法——每只筷子都用一个信号量来表示（会造成死锁）"></a>第一种解法——每只筷子都用一个信号量来表示（会造成死锁）</h4><p>共享数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>哲学家i的结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    wait(chopstick[i]);</span><br><span class="line">    wait(chopstick[i+<span class="number">1</span>]%<span class="number">5</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//eat</span></span><br><span class="line">    ...</span><br><span class="line">    signal(chopstick[i]);</span><br><span class="line">    signal(chopstick[i+<span class="number">1</span>]%<span class="number">5</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//think</span></span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>但是这种解答会造成死锁。</p><p>解决方法：</p><blockquote><p>1.最多只允许4个哲学家同时坐在位子上</p></blockquote><blockquote><p>2.只有两支筷子都可用时才允许一个哲学家拿起它们</p></blockquote><blockquote><p>3.使用非对称解决方法，即奇数哲学家先拿起左边的筷子，偶数哲学家先拿起右边的筷子</p></blockquote><h4 id="使用管程解决"><a href="#使用管程解决" class="headerlink" title="使用管程解决"></a>使用管程解决</h4><p>数据结构和算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">monitor dp</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; THINKING, HUNGRY, EATING &#125; state[<span class="number">5</span>];</span><br><span class="line">    condition self[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pickup</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//拿起筷子的动作</span></span><br><span class="line">        state[i] = HUNGRY;</span><br><span class="line">        test(i);</span><br><span class="line">        <span class="keyword">if</span>(state[i] != EATING)</span><br><span class="line">            self[i].wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putdown</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//放下筷子</span></span><br><span class="line">        state[i] = THINKING;</span><br><span class="line">        test((i+<span class="number">4</span>)%<span class="number">5</span>);</span><br><span class="line">        test((i+<span class="number">1</span>)%<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((state[(i+<span class="number">4</span>)%<span class="number">5</span>] != EATING))&amp;&amp;<span class="comment">//左边的筷子没有使用</span></span><br><span class="line">            (state[i] == HUNGRY)&amp;&amp;<span class="comment">//处于饥饿状态</span></span><br><span class="line">            (state[(i+<span class="number">1</span>)%<span class="number">5</span>] != EATING)&#123;<span class="comment">//右边的筷子没有使用</span></span><br><span class="line">                state[i] = EATING;</span><br><span class="line">                self[i].signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initialization_code()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)</span><br><span class="line">            state[i] = THINKING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哲学家i的结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp.pickup(i);</span><br><span class="line">...</span><br><span class="line">eat</span><br><span class="line">...</span><br><span class="line">dp.putdown(i);</span><br></pre></td></tr></table></figure><h2 id="管程（monitor）"><a href="#管程（monitor）" class="headerlink" title="管程（monitor）"></a>管程（monitor）</h2><p>为了防止由于编程等错误导致的wait()和signal()的位置调换或缺失，我们使用类型或抽象数据类型，封装了私有数据类型及操作数据的公有方法。管程结构确保一次只有一个进程能在管程内活动。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS CPU调度</title>
      <link href="/2020/01/06/osCPU%E8%B0%83%E5%BA%A6/"/>
      <url>/2020/01/06/osCPU%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h1><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>多道程序的目标是在任何时候都有某些进程在运行，使CPU使用率最大化。当一个进程执行到等待的时候，操作系统就拿走CPU使用权交给其他就绪的进程。</p><h3 id="CPU-I-O区间周期"><a href="#CPU-I-O区间周期" class="headerlink" title="CPU-I/O区间周期"></a>CPU-I/O区间周期</h3><p>进程执行从<strong>CPU区间（CPU burst）</strong>开始，之后使<strong>I/O区间（I/O burst）</strong>，接着使另一个CPU区间，然后使另一个I/O区间，以此循环，最终在最后的CPU区间通过系统请求终止执行。I/O约束程序通常具有很多短CPU区间；CPU约束程序可能有少量的长CPU区间。</p><h3 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h3><p>CPU空闲时，操作系统就会从就绪队列中选择一个进程来执行。这个操作通常由<strong>短期调度程序（short-term scheduler）</strong>或CPU调度程序执行。</p><h3 id="抢占调度"><a href="#抢占调度" class="headerlink" title="抢占调度"></a>抢占调度</h3><p>CPU调度决策在如下4种环境发生：</p><blockquote><ul><li>1.当一个进程从运行状态切换到等待状态</li><li>2.当一个进程从运行状态切换到就绪状态</li><li>2.当一个进程从等待状态切换到就绪状态</li><li>3.当一个进程终止</li></ul></blockquote><p>当调度只能发生在第1和第4两种情况下时，称调度方案是<strong>非抢占的（nonpreemptive）</strong>或<strong>协作的（cooperative）</strong>；否则，称调度方案是<strong>抢占的（preemptive）</strong>。抢占调度对访问共享数据是有代价的，同时对内核设计也有影响。</p><h3 id="分派程序（dispatcher）"><a href="#分派程序（dispatcher）" class="headerlink" title="分派程序（dispatcher）"></a>分派程序（dispatcher）</h3><p>功能：</p><blockquote><ul><li>切换上下文</li><li>切换到用户模式</li><li>跳转到用户程序的合适位置，以重新启动程序</li></ul></blockquote><p>分配程序停止一个进程而启动另一个所要花费的时间称为分派延迟（dispatch latency）。</p><h2 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h2><ul><li><p>CPU使用率</p></li><li><p>吞吐量</p><blockquote><p>单位时间内所完成进程的数量</p></blockquote></li><li><p>周转时间</p><blockquote><p>从进程提交到进程完成的时间段称为周转时间</p></blockquote></li><li><p>等待时间</p><blockquote><p>在就绪队列中等待所花费的时间之和</p></blockquote></li><li><p>响应时间</p><blockquote><p>从进程提交到产生第一次响应的时间。</p></blockquote><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2></li><li><p><em>Gantt图*</em>通过条状图来显示项目，进度和其他时间相关的系统进展的内在关系随着时间进展的情况。</p><h3 id="先到先服务调度（first-come-first-served-FCFS-scheduling-algorithm）"><a href="#先到先服务调度（first-come-first-served-FCFS-scheduling-algorithm）" class="headerlink" title="先到先服务调度（first-come,first-served(FCFS) scheduling algorithm）"></a>先到先服务调度（first-come,first-served(FCFS) scheduling algorithm）</h3><p>先请求CPU的进程先分配到CPU。该策略可以用FIFO队列来容易地实现。</p></li></ul><p>优点：</p><blockquote><ul><li>代码编写简单且容易理解</li></ul></blockquote><p>缺点：</p><blockquote><ul><li>平均等待时间通常较长</li><li>容易产生护航效果（convoy effect）（所有其他进程都等待一个大进程释放CPU）</li></ul></blockquote><p>FCFS调度算法是非抢占式的。</p><h3 id="最短作业优先调度（shortest-job-first-SJF-scheduling-algorithm）"><a href="#最短作业优先调度（shortest-job-first-SJF-scheduling-algorithm）" class="headerlink" title="最短作业优先调度（shortest-job-first(SJF) scheduling algorithm）"></a>最短作业优先调度（shortest-job-first(SJF) scheduling algorithm）</h3><p>当CPU空闲时，它会赋给具有最短CPU区间的进程。如果两个进程有同样的长度，那么就可以使用FCFS调度来处理。通常用于长期调度。</p><p>优点：</p><blockquote><ul><li>平均等待时间最短</li></ul></blockquote><p>缺点：</p><blockquote><ul><li>需要知道下一个CPU区间的长度</li><li>不能再短期CPU调度层次上加以实现。</li></ul></blockquote><p><strong>近似SJF调度</strong>：<br>下一个CPU区间预测为以前CPU区间的测量长度的指数平均。</p><p>SJF调度算法可以时抢占或非抢占的。</p><p>抢占式SJF算法又称为<strong>最短剩余时间优先调度（shortest-remaining-time-first scheduling）</strong>：当一个新进程如果到达就绪队列且它的CPU区间更短，就抢占当前进程。</p><p>非抢占式允许当前运行的进程先完成其CPU区间。</p><h3 id="优先级调度（priority-scheduling-algorithm）"><a href="#优先级调度（priority-scheduling-algorithm）" class="headerlink" title="优先级调度（priority scheduling algorithm）"></a>优先级调度（priority scheduling algorithm）</h3><p>每个进程都有一个优先级与其相关联，具有最高优先级的进程会分配到CPU。具有相同优先级的按FCFS调度来处理。优先级可以通过内部或外部方式来定义。内部定义优先级使用一些测量数据（时间极限、内存要求、打开文件的数量和平均I/O区间与平均CPU区间之比）以计算进程优先级。外部优先级是通过操作系统外的准则（进程重要性、用于支付使用计算机的费用类型等）来定义的。</p><p>优先级调度可以说抢占式或非抢占式。</p><p>缺点：</p><blockquote><ul><li>会出现<strong>无穷阻塞（indefinite blocking）</strong>或<strong>饥饿（starvation）</strong>（指可以运行但是缺乏CPU的进程）</li></ul></blockquote><p>通过老化（aging，随着时间的增加增加优先级）可以解决阻塞问题。</p><h3 id="轮转法调度（round-robin，RR）"><a href="#轮转法调度（round-robin，RR）" class="headerlink" title="轮转法调度（round-robin，RR）"></a>轮转法调度（round-robin，RR）</h3><p>专门为分时系统设计。它类似于FCFS调度，但是增加了抢占切换进程。定义一个较小时间单元（时间片）为进程的CPU区间。若进程运行了一个时间片的时间还没有停止就被抢占，而CPU交给下一个进程。</p><p>缺点：</p><blockquote><ul><li>时间片太短会导致CPU效率降低，时间片太长RR调度也就变成了FCFS调度。</li></ul></blockquote><h3 id="多级队列调度（multilevel-queue-scheduling-algorithm）"><a href="#多级队列调度（multilevel-queue-scheduling-algorithm）" class="headerlink" title="多级队列调度（multilevel queue scheduling algorithm）"></a>多级队列调度（multilevel queue scheduling algorithm）</h3><p>将进程分成不同的组，例如，前台（交互）进程和后台（批处理）进程。然后根据进程的属性（内存大小、进程优先级、进程类型），一个进程被永久的分配到一个队列。每个队列有自己的调度算法。另外，队列之间也有调度，通常采用固定优先级抢占调度，通常采用固定优先级抢占调度。</p><h3 id="多级反馈队列调度（multilevel-queue-scheduling-algorithm）"><a href="#多级反馈队列调度（multilevel-queue-scheduling-algorithm）" class="headerlink" title="多级反馈队列调度（multilevel queue scheduling algorithm）"></a>多级反馈队列调度（multilevel queue scheduling algorithm）</h3><p>为了解决多级队列调度不够灵活的问题，避免出现饥饿的发生，多级反馈队列调度允许进程在队列之间移动。通常是根据不同CPU区间的特点以区分进程。它通多下列参数来定义：</p><blockquote><ul><li>队列数量</li><li>每个队列的调度算法</li><li>用以确定何时升级到更高优先级队列的方法</li><li>用以确定何时降级到更低优先级队列的方法</li><li>用以确定进程在需要服务时应进入哪个队列的方法</li></ul></blockquote><p>缺点：</p><blockquote><ul><li>过于复杂</li></ul></blockquote><h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>如果有多个处理器，则负载分配（loading sharing）成为可能。</p><h3 id="多处理器调度的方法"><a href="#多处理器调度的方法" class="headerlink" title="多处理器调度的方法"></a>多处理器调度的方法</h3><h4 id="非对称多处理器（asymmetric-multiprocessing）"><a href="#非对称多处理器（asymmetric-multiprocessing）" class="headerlink" title="非对称多处理器（asymmetric multiprocessing）"></a>非对称多处理器（asymmetric multiprocessing）</h4><p>让一个处理器处理所有的调度决定、I/O处理以及其他的系统活动，其他的处理器只执行用户代码。</p><h4 id="对称多处理器（symmetric-multiproccessing，SMP）"><a href="#对称多处理器（symmetric-multiproccessing，SMP）" class="headerlink" title="对称多处理器（symmetric multiproccessing，SMP）"></a>对称多处理器（symmetric multiproccessing，SMP）</h4><p>每个处理器自我调度。所有进程可能处于一个共同的就绪队列中，或每个处理器都有它自己私有的就绪进程队列。</p><h3 id="处理器亲和性"><a href="#处理器亲和性" class="headerlink" title="处理器亲和性"></a>处理器亲和性</h3><p>努力使一个进程在同一个处理器上运行。不能做到保证叫做软亲和性（soft affinity），允许进程指定它不移植到其他处理器叫做硬亲和性（hard affinity）</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h2 id="算法评估"><a href="#算法评估" class="headerlink" title="算法评估"></a>算法评估</h2><blockquote><ul><li>最大化CPU使用率，同时要求最大响应时间为1s</li><li>最大化吞吐量</li></ul></blockquote><h3 id="确定模型（deterministic-modeling）"><a href="#确定模型（deterministic-modeling）" class="headerlink" title="确定模型（deterministic modeling）"></a>确定模型（deterministic modeling）</h3><p>分析评估发（analytic evaluation），使用给定算法和系统负荷，产生公式或数字，以评估对于该负荷算法的性能。确定模型法使其中一种。主要比较平均等待时间。</p><h3 id="排队模型"><a href="#排队模型" class="headerlink" title="排队模型"></a>排队模型</h3><p>用到达率和服务率计算使用率、平均队列长度、平均等待时间，成为排队网络分析（queueing-network analysis）。</p><p><strong>Little公式</strong>：<br>设n为平均队列长度，W为队列的平均等待时间，λ为新进程到达队列的平均到达率。有</p><center>n=λ*W</center><h3 id="模拟（simulation）"><a href="#模拟（simulation）" class="headerlink" title="模拟（simulation）"></a>模拟（simulation）</h3><p>对计算机系统建模。用软件数据表示系统的主要组成部分。用一个变量的改变反映设备、进程、和调度程序的活动。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>最精确的办法就是实现代码将其放到操作系统内，并观测它如何工作，在真是操作系统内进行评估。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
